<!-- Staff Chat Interface Content -->
<div class="h-full flex flex-col lg:flex-row gap-4" x-data="staffChat()" x-init="init()">
    
    <!-- Left Sidebar - Conversations List -->
    <div class="lg:w-80 flex flex-col bg-white rounded-lg shadow overflow-hidden">
        <!-- Search -->
        <div class="p-4 border-b border-gray-200">
            <div class="relative">
                <input type="text" 
                       x-model="searchQuery"
                       @input="searchConversations()"
                       placeholder="Tìm kiếm khách hàng..."
                       class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent">
                <i class="fas fa-search absolute left-3 top-3 text-gray-400"></i>
            </div>
        </div>
        
        <!-- Conversations List -->
        <div class="flex-1 overflow-y-auto chat-scrollbar">
            <template x-if="loading">
                <div class="flex items-center justify-center p-8">
                    <div class="spinner"></div>
                </div>
            </template>
            
            <template x-if="!loading && conversations.length === 0">
                <div class="text-center py-12 px-4">
                    <i class="fas fa-comments text-gray-300 text-5xl mb-4"></i>
                    <p class="text-gray-500">Chưa có cuộc hội thoại nào</p>
                </div>
            </template>
            
            <template x-for="conv in conversations" :key="conv.id.toString()">
                <div @click="selectConversation(conv)" 
                     @click.prevent="selectConversation(conv)"
                     :class="{'bg-primary-50 border-l-4 border-primary-500': selectedConversation && selectedConversation.id === conv.id}"
                     class="conversation-item p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition-colors">
                    <div class="flex items-start space-x-3">
                        <!-- Avatar -->
                        <div class="flex-shrink-0 relative">
                            <template x-if="conv.customerAvatar">
                                <img :src="conv.customerAvatar" :alt="conv.customerName" 
                                     class="w-12 h-12 rounded-full object-cover">
                            </template>
                            <template x-if="!conv.customerAvatar">
                                <div class="w-12 h-12 rounded-full bg-primary-500 flex items-center justify-center">
                                    <span class="text-white font-semibold text-lg" x-text="conv.customerName.charAt(0)"></span>
                                </div>
                            </template>
                            <template x-if="conv.unreadCount > 0">
                                <span class="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full w-5 h-5 flex items-center justify-center"
                                      x-text="conv.unreadCount"></span>
                            </template>
                        </div>
                        
                        <!-- Info -->
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center justify-between mb-1">
                                <h4 class="font-semibold text-gray-900 truncate" x-text="conv.customerName"></h4>
                                <div class="flex items-center space-x-2">
                                    <span class="text-xs text-gray-500" x-text="formatTime(conv.lastMessageAt)"></span>
                                    <template x-if="conv.status === 'OPEN'">
                                        <button @click.stop="assignConversation(conv.id)" 
                                                class="px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors">
                                            <i class="fas fa-hand-paper mr-1"></i>Nhận
                                        </button>
                                    </template>
                                </div>
                            </div>
                            <p class="text-sm text-gray-600 truncate" x-text="conv.lastMessageContent || 'Chưa có tin nhắn'"></p>
                            <div class="flex items-center space-x-2 mt-1">
                                <template x-if="conv.status === 'OPEN'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-yellow-100 text-yellow-800">
                                        <i class="fas fa-clock mr-1"></i> Chưa xử lý
                                    </span>
                                </template>
                                <template x-if="conv.status === 'ASSIGNED'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                                        <i class="fas fa-user mr-1"></i> Đã nhận
                                    </span>
                                </template>
                                <template x-if="conv.priority === 'HIGH'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-100 text-orange-800">
                                        <i class="fas fa-exclamation-circle mr-1"></i> Cao
                                    </span>
                                </template>
                                <template x-if="conv.priority === 'URGENT'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                                        <i class="fas fa-exclamation-triangle mr-1"></i> Khẩn cấp
                                    </span>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
    
    <!-- Main Chat Area -->
    <div class="flex-1 flex flex-col bg-white rounded-lg shadow overflow-hidden">
        <template x-if="!selectedConversation">
            <div class="flex-1 flex items-center justify-center">
                <div class="text-center">
                    <i class="fas fa-comments text-gray-300 text-6xl mb-4"></i>
                    <p class="text-gray-500 text-lg">Chọn cuộc hội thoại để bắt đầu</p>
                </div>
            </div>
        </template>
        
        <template x-if="selectedConversation">
            <div class="flex-1 flex flex-col h-full">
                <!-- Chat Header -->
                <div class="px-6 py-4 border-b border-gray-200 bg-gradient-to-r from-primary-50 to-pink-50">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <template x-if="selectedConversation.customerAvatar">
                                <img :src="selectedConversation.customerAvatar" 
                                     :alt="selectedConversation.customerName" 
                                     class="w-10 h-10 rounded-full object-cover">
                            </template>
                            <template x-if="!selectedConversation.customerAvatar">
                                <div class="w-10 h-10 rounded-full bg-primary-500 flex items-center justify-center">
                                    <span class="text-white font-semibold" x-text="selectedConversation.customerName.charAt(0)"></span>
                                </div>
                            </template>
                            <div>
                                <h3 class="font-semibold text-gray-900" x-text="selectedConversation.customerName"></h3>
                                <p class="text-sm text-gray-600" x-text="selectedConversation.customerEmail"></p>
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            
                            <!-- Nút AI - trao lại cho AI sau 30s -->
                            <template x-if="selectedConversation && selectedConversation.status === 'ASSIGNED' && selectedConversation.assignedStaffId && Number(selectedConversation.assignedStaffId) === Number(staffId)">
                                <button @click="returnToAi()"
                                        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors shadow-md"
                                        title="Trao lại cho AI sau 30 giây nếu khách không nhắn tin"
                                        :disabled="returningToAi">
                                    <template x-if="!returningToAi">
                                        <span><i class="fas fa-robot mr-2"></i>AI</span>
                                    </template>
                                    <template x-if="returningToAi">
                                        <span><i class="fas fa-spinner fa-spin mr-2"></i>Đang xử lý...</span>
                                    </template>
                                </button>
                            </template>
                            
                            <!-- Nút Đóng -->
                            <template x-if="selectedConversation.status !== 'CLOSED'">
                                <button @click="closeConversation()" 
                                        class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                                    <i class="fas fa-times mr-2"></i>Đóng
                                </button>
                            </template>
                            
                            <!-- Nút Mở lại -->
                            <template x-if="selectedConversation.status === 'CLOSED'">
                                <button @click="reopenConversation()" 
                                        class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                                    <i class="fas fa-redo mr-2"></i>Mở lại
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
                
                <!-- Messages Area -->
                <div class="flex-1 overflow-y-auto p-4 bg-gradient-to-b from-gray-50 to-white chat-scrollbar" 
                     id="messagesContainer"
                     @scroll="handleScroll"
                     style="height: calc(100vh - 300px); max-height: calc(100vh - 300px); min-height: 400px;">
                    <template x-if="loadingMessages">
                        <div class="flex items-center justify-center p-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-pink-500"></div>
                        </div>
                    </template>
                    
                    <template x-for="msg in messages" :key="msg.id.toString()">
                        <div>
                            <!-- System Message (Center) -->
                            <template x-if="msg.messageType === 'SYSTEM'">
                                <div class="flex justify-center w-full mb-4">
                                    <div class="bg-yellow-100 text-yellow-800 px-4 py-2 rounded-full text-sm font-medium shadow-sm">
                                        <i class="fas fa-info-circle mr-2"></i>
                                        <span x-text="msg.content"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Staff Message (Right) -->
                            <template x-if="msg.senderId === staffId && msg.messageType !== 'SYSTEM'">
                                <div class="flex justify-end mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="flex flex-col items-end">
                                            <div class="bg-gradient-to-r from-pink-500 to-purple-600 text-white px-4 py-3 rounded-2xl rounded-br-md shadow-lg">
                                                <p class="text-sm leading-relaxed" x-text="msg.content"></p>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-pink-500 to-purple-600 flex items-center justify-center text-white text-sm font-semibold">
                                            S
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- AI Message (Left with special styling) -->
                            <template x-if="msg.isAiGenerated && msg.senderId !== staffId">
                                <div class="flex justify-start mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-purple-500 to-indigo-600 flex items-center justify-center text-white text-sm font-semibold">
                                            🤖
                                        </div>
                                        <div class="flex flex-col items-start">
                                            <div class="bg-gradient-to-r from-purple-100 to-indigo-100 text-purple-800 px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-purple-200">
                                                <div class="text-sm leading-relaxed" x-html="parseMarkdown(msg.content)"></div>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Customer Message (Left) -->
                            <template x-if="msg.senderId !== staffId && msg.messageType === 'TEXT' && !msg.isAiGenerated">
                                <div class="flex justify-start mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center text-white text-sm font-semibold">
                                            <span x-text="selectedConversation.customerName.charAt(0)"></span>
                                        </div>
                                        <div class="flex flex-col items-start">
                                            <div class="bg-white text-gray-800 px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-gray-100">
                                                <p class="text-sm leading-relaxed" x-text="msg.content"></p>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                    
                    <!-- Typing Indicator -->
                    <template x-if="isTyping">
                        <div class="flex justify-start mb-4">
                            <div class="flex items-end space-x-2">
                                <div class="w-8 h-8 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center text-white text-sm font-semibold">
                                    <span x-text="selectedConversation.customerName.charAt(0)"></span>
                                </div>
                                <div class="bg-white px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-gray-100">
                                    <div class="flex space-x-1">
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Message Input -->
                <div class="p-4 bg-white border-t border-gray-200 flex-shrink-0">
                    <div class="flex items-end space-x-3">
                        <div class="flex-1 relative">
                            <textarea x-model="messageText"
                                     @keydown.enter.prevent="sendMessage()"
                                     @input="handleTyping()"
                                     placeholder="Nhập tin nhắn..."
                                     rows="1"
                                     class="w-full px-4 py-3 pr-12 border border-gray-300 rounded-2xl resize-none focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-200 bg-gray-50 focus:bg-white"
                                     style="min-height: 44px; max-height: 120px;"></textarea>
                            <div class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm">
                                <i class="fas fa-paperclip"></i>
                            </div>
                        </div>
                        <button @click="sendMessage()"
                                :disabled="!messageText.trim() || sendingMessage"
                                class="w-12 h-12 bg-gradient-to-r from-pink-500 to-purple-600 text-white rounded-full flex items-center justify-center transition-all duration-200 hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
                            <template x-if="!sendingMessage">
                                <i class="fas fa-paper-plane text-lg"></i>
                            </template>
                            <template x-if="sendingMessage">
                                <i class="fas fa-spinner fa-spin text-lg"></i>
                            </template>
                        </button>
                    </div>
                </div>
            </div>
        </template>
    </div>
    
    <!-- Right Sidebar - Customer Info (Hidden on mobile) -->
    <div class="hidden xl:block w-80 bg-white rounded-lg shadow p-6" x-show="selectedConversation">
        <h3 class="text-lg font-semibold text-gray-900 mb-4">
            <i class="fas fa-info-circle mr-2 text-primary-600"></i>
            Thông tin khách hàng
        </h3>
        
        <template x-if="selectedConversation">
            <div class="space-y-4">
                <!-- Customer Details -->
                <div class="border-b border-gray-200 pb-4">
                    <div class="text-center mb-4">
                        <template x-if="selectedConversation.customerAvatar">
                            <img :src="selectedConversation.customerAvatar" 
                                 :alt="selectedConversation.customerName" 
                                 class="w-20 h-20 rounded-full object-cover mx-auto mb-3">
                        </template>
                        <template x-if="!selectedConversation.customerAvatar">
                            <div class="w-20 h-20 rounded-full bg-primary-500 flex items-center justify-center mx-auto mb-3">
                                <span class="text-white font-bold text-2xl" x-text="selectedConversation.customerName.charAt(0)"></span>
                            </div>
                        </template>
                        <h4 class="font-semibold text-gray-900" x-text="selectedConversation.customerName"></h4>
                    </div>
                    
                    <div class="space-y-2 text-sm">
                        <div class="flex items-center text-gray-600">
                            <i class="fas fa-envelope w-6"></i>
                            <span x-text="selectedConversation.customerEmail"></span>
                        </div>
                        <template x-if="selectedConversation.customerPhone">
                            <div class="flex items-center text-gray-600">
                                <i class="fas fa-phone w-6"></i>
                                <span x-text="selectedConversation.customerPhone"></span>
                            </div>
                        </template>
                    </div>
                </div>
                
                <!-- Conversation Info -->
                <div class="border-b border-gray-200 pb-4">
                    <h5 class="font-semibold text-gray-900 mb-3">Thông tin cuộc hội thoại</h5>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Trạng thái:</span>
                            <span class="font-medium" x-text="getStatusText(selectedConversation.status)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Độ ưu tiên:</span>
                            <span class="font-medium" x-text="getPriorityText(selectedConversation.priority)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Bắt đầu:</span>
                            <span x-text="formatDateTime(selectedConversation.createdAt)"></span>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Actions -->
                <div>
                    <h5 class="font-semibold text-gray-900 mb-3">Thao tác nhanh</h5>
                    <div class="space-y-2">
                        <button class="w-full px-4 py-2 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 transition-colors text-sm">
                            <i class="fas fa-user mr-2"></i>Xem hồ sơ khách hàng
                        </button>
                        <button class="w-full px-4 py-2 bg-green-50 text-green-700 rounded-lg hover:bg-green-100 transition-colors text-sm">
                            <i class="fas fa-shopping-cart mr-2"></i>Xem đơn hàng
                        </button>
                    </div>
                </div>
            </div>
        </template>
    </div>
</div>

<script th:inline="none">
function staffChat() {
    return {
        staffId: Number(/*[[${staffId}]]*/ 10), // Force number type
        conversations: [],
        selectedConversation: null,
        messages: [],
        messageText: '',
        searchQuery: '',
        loading: false,
        loadingMessages: false,
        sendingMessage: false,
        returningToAi: false, // Flag to prevent duplicate AI return calls
        isTyping: false,
        typingTimeout: null,
        stompClient: null,
        currentSubscription: null,
        
        async init() {
            await this.loadConversations();
            this.connectWebSocket();
            
            // Check if conversation ID in URL
            const urlParams = new URLSearchParams(window.location.search);
            const convId = urlParams.get('conversation');
            if (convId) {
                const conv = this.conversations.find(c => c.id == convId);
                if (conv) {
                    await this.selectConversation(conv);
                } else {
                }
            }
            
            // Setup real-time updates like Messenger/Zalo
            this.setupRealTimeUpdates();
            
            // Cleanup processed messages periodically to prevent memory leak
            this.setupProcessedMessagesCleanup();
            
        },
        
        async loadConversations() {
            this.loading = true;
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch('/api/staff/conversations?page=0&size=50', {
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.conversations = data.data || [];
                    // Debug each conversation
                    this.conversations.forEach((conv, index) => {
                            status: conv.status
                        });
                    });
                } else {
                    console.error('❌ Error loading conversations:', data.error);
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Reload current conversation data (for UI updates after status changes)
         */
        async reloadCurrentConversation() {
            if (!this.selectedConversation) {
                return;
            }
            
            const conversationId = this.selectedConversation.id;
            
            try {
                // Reload conversation list to get updated data
                await this.loadConversations();
                
                // Find the updated conversation in the list
                const updatedConv = this.conversations.find(c => c.id == conversationId);
                
                if (updatedConv) {
                    // Update selectedConversation with new data
                    this.selectedConversation = updatedConv;
                } else {
                }
            } catch (error) {
                console.error('Error reloading conversation:', error);
            }
        },
        
        async selectConversation(conv) {
            
            // Validate conversation object
            if (!conv || !conv.id) {
                console.error('❌ Invalid conversation object:', conv);
                return;
            }
            
            // Ensure conversation ID is a number
            const conversationId = parseInt(conv.id);
            if (isNaN(conversationId)) {
                console.error('❌ Invalid conversation ID:', conv.id);
                return;
            }
            
            
            // Unsubscribe from previous conversation if exists
            if (this.currentSubscription && this.stompClient && this.stompClient.connected) {
                try {
                    this.currentSubscription.unsubscribe();
                } catch (error) {
                    console.error('Error unsubscribing from previous conversation:', error);
                }
            }
            
            // Create a clean conversation object with ALL fields to avoid reference issues
            this.selectedConversation = {
                id: conversationId,
                customerId: conv.customerId,
                customerName: conv.customerName,
                customerEmail: conv.customerEmail,
                customerPhone: conv.customerPhone,
                customerAvatar: conv.customerAvatar,
                lastMessage: conv.lastMessage,
                lastMessageAt: conv.lastMessageAt,
                lastMessageSender: conv.lastMessageSender,
                status: conv.status,
                priority: conv.priority,
                unreadCount: conv.unreadCount,
                createdAt: conv.createdAt,
                assignedStaffId: conv.assignedStaffId,
                assignedStaffName: conv.assignedStaffName
            };
            
            
            // Clear current messages before loading new ones
            this.messages = [];
            
            await this.loadMessages(conversationId);
            
            // Mark as read when staff opens the conversation
            this.markAsRead(conversationId);
            
            // Update unread count immediately in UI
            this.updateUnreadCountAfterMarkAsRead(conversationId);
            
            // Subscribe to this specific conversation
            if (this.stompClient && this.stompClient.connected) {
                try {
                    this.currentSubscription = this.stompClient.subscribe('/topic/chat/' + conversationId, (message) => {
                        const msg = JSON.parse(message.body);
                        this.handleIncomingMessage(msg);
                    });
                } catch (error) {
                    console.error('Error subscribing to conversation:', error);
                }
            }
            
            // Force scroll to bottom after loading messages
            setTimeout(() => {
                this.scrollToBottom();
            }, 200);
            
            // Also scroll after next tick
            this.$nextTick(() => {
                this.scrollToBottom();
            });
        },
        
        async loadMessages(conversationId) {
            console.log('📥 Loading messages for conversation:', conversationId);
            console.log('📥 ConversationId type:', typeof conversationId);
            
            // Validate conversationId
            if (!conversationId || isNaN(parseInt(conversationId))) {
                console.error('❌ Invalid conversationId for loadMessages:', conversationId);
                return;
            }
            
            // Ensure conversationId is a number
            const validConversationId = parseInt(conversationId);
            console.log('📥 Valid conversationId:', validConversationId);
            
            this.loadingMessages = true;
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const url = `/api/chat/conversations/${validConversationId}/messages?page=0&size=100`;
                console.log('📥 Fetching URL:', url);
                
                const response = await fetch(url, {
                    headers: headers
                });
                
                console.log('📥 Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('📥 Response data:', data);
                
                if (data.data && !data.error) {
                    this.messages = (data.data || []).reverse();
                    console.log('✅ Loaded messages:', this.messages.length, 'messages');
                    console.log('✅ Messages:', this.messages);
                    
                    // Force scroll to bottom after messages are loaded
                    setTimeout(() => {
                        this.scrollToBottom();
                    }, 100);
                } else {
                    console.error('❌ Error loading messages:', data.error);
                    this.messages = [];
                }
            } catch (error) {
                console.error('❌ Error loading messages:', error);
                this.messages = [];
            } finally {
                this.loadingMessages = false;
                
                // Final scroll to bottom after loading is complete
                setTimeout(() => {
                    this.scrollToBottom();
                }, 300);
            }
        },
        
        async sendMessage() {
            if (!this.messageText.trim() || !this.selectedConversation || this.sendingMessage) return;
            
            const messageContent = this.messageText.trim();
            this.sendingMessage = true;
            
            // Create optimistic message for immediate display
            const optimisticMessage = {
                id: 'temp_' + Date.now(), // Temporary ID
                conversationId: this.selectedConversation.id,
                senderId: this.staffId,
                receiverId: this.selectedConversation.customerId,
                content: messageContent,
                messageType: 'TEXT',
                sentAt: new Date().toISOString(),
                isRead: false,
                isOptimistic: true // Flag to identify optimistic messages
            };
            
            // Add optimistic message to UI immediately
            this.messages.push(optimisticMessage);
            this.messageText = '';
            
            // Scroll to bottom immediately
            this.$nextTick(() => this.scrollToBottom());
            
            try {
                const messageDTO = {
                    conversationId: this.selectedConversation.id.toString(),
                    senderId: this.staffId,
                    receiverId: this.selectedConversation.customerId,
                    content: messageContent,
                    messageType: 'TEXT'
                };
                
                let sentMessage = null;
                
                // Send via WebSocket if connected
                if (this.stompClient && this.stompClient.connected) {
                    try {
                        this.stompClient.send('/app/chat.send', {}, JSON.stringify(messageDTO));
                        // For WebSocket, we'll get the response via handleIncomingMessage
                        // The optimistic message will be replaced when we receive the real message
                    } catch (error) {
                        console.error('Error sending via WebSocket:', error);
                        // Fallback to REST API
                        sentMessage = await this.sendMessageViaRest(messageDTO);
                    }
                } else {
                    // Fallback to REST API
                    sentMessage = await this.sendMessageViaRest(messageDTO);
                }
                
                // If we got a response from REST API, replace optimistic message
                if (sentMessage) {
                    this.replaceOptimisticMessage(optimisticMessage.id, sentMessage);
                }
                
            } catch (error) {
                console.error('Error sending message:', error);
                // Remove optimistic message on error
                this.removeOptimisticMessage(optimisticMessage.id);
                if (typeof showError === 'function') {
                    showError('Không thể gửi tin nhắn');
                }
            } finally {
                this.sendingMessage = false;
            }
        },
        
        handleIncomingMessage(msg) {
            console.log('🔔 handleIncomingMessage called:', msg);
            console.log('Current staffId:', this.staffId);
            console.log('Message senderId:', msg.senderId);
            console.log('Is from customer:', msg.senderId != this.staffId);
            console.log('Selected conversation:', this.selectedConversation);
            
            // ⚠️ CRITICAL: Prevent duplicate processing from multiple WebSocket subscriptions
            // Message can be received from both /topic/chat/{conversationId} and /topic/chat/staff
            const messageProcessedKey = `processed_${msg.id}`;
            if (this[messageProcessedKey]) {
                console.log('⚠️ Message already processed, skipping duplicate processing');
                return;
            }
            
            // Mark this message as processed to prevent duplicate
            this[messageProcessedKey] = true;
            
            // Check if this message is already in the messages array to avoid duplicates
            const messageExists = this.messages.some(m => m.id === msg.id);
            if (messageExists) {
                console.log('⚠️ Message already exists in chat, skipping duplicate');
                return;
            }
            
            // If this is a message from staff (current user), check if we have an optimistic message to replace
            if (msg.senderId === this.staffId) {
                const optimisticIndex = this.messages.findIndex(m => m.isOptimistic && m.content === msg.content);
                if (optimisticIndex !== -1) {
                    console.log('🔄 Replacing optimistic message with real message');
                    this.messages[optimisticIndex] = msg;
                    this.$nextTick(() => this.scrollToBottom());
                    
                    // CRITICAL: Update selectedConversation status when staff sends message
                    // This ensures AI button appears immediately without page reload
                    if (this.selectedConversation && this.selectedConversation.id == msg.conversationId) {
                        console.log('🔄 Updating selectedConversation status to ASSIGNED after staff message');
                        this.selectedConversation.status = 'ASSIGNED';
                        this.selectedConversation.assignedStaffId = this.staffId;
                        console.log('✅ Updated selectedConversation:', this.selectedConversation);
                    }
                    return;
                }
            }
            
            // Determine if staff is viewing this conversation
            const isViewingConversation = this.selectedConversation && msg.conversationId == this.selectedConversation.id;
            console.log('Is viewing conversation:', isViewingConversation);
            
            // Update conversation list BEFORE adding message to chat
            // This ensures unread count is updated correctly
            this.updateConversationInList(msg.conversationId, msg, isViewingConversation);
            
            // If staff is currently viewing this conversation, add message to chat
            if (isViewingConversation) {
                console.log('✅ Staff is viewing this conversation, adding message to chat');
                this.messages.push(msg);
                this.$nextTick(() => this.scrollToBottom());
                
                // If this is a system message or AI message, reload conversation data to update UI
                if (msg.isAiGenerated || msg.senderName === 'Hệ thống') {
                    console.log('🔄 System/AI message detected, reloading conversation data...');
                    this.reloadCurrentConversation();
                }
                
                // If message is from customer, mark as read immediately (staff is viewing)
                if (msg.senderId != this.staffId) {
                    console.log('Message from customer, marking as read immediately');
                    // Mark as read immediately since staff is viewing
                    this.markAsRead(this.selectedConversation.id);
                }
            } else {
                console.log('❌ Staff is NOT viewing this conversation');
                // Staff is not viewing this conversation, show notification
                if (msg.senderId != this.staffId) {
                    console.log('Showing notification for new message');
                    this.showNotification(`Tin nhắn mới từ ${msg.senderName || 'Khách hàng'}`);
                }
            }
        },
        
        async markAsRead(conversationId) {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                // Add JWT token from cookie for authentication
                const authToken = this.getCookie('authToken');
                if (authToken) {
                    headers['Authorization'] = 'Bearer ' + authToken;
                }
                
                await fetch(`/api/chat/conversations/${conversationId}/read`, {
                    method: 'PUT',
                    headers: headers
                });
                
                // Update unread count immediately in UI
                this.updateUnreadCountAfterMarkAsRead(conversationId);
                
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        },
        
        getCsrfToken() {
            const token = document.querySelector('meta[name="_csrf"]');
            const header = document.querySelector('meta[name="_csrf_header"]');
            return {
                token: token ? token.getAttribute('content') : null,
                header: header ? header.getAttribute('content') : null
            };
        },
        
        getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        },
        
        async sendMessageViaRest(messageDTO) {
            const csrf = this.getCsrfToken();
            const headers = {
                'Content-Type': 'application/json'
            };
            if (csrf.token) {
                headers[csrf.header] = csrf.token;
            }
            
            const response = await fetch('/api/chat/messages', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(messageDTO)
            });
            const data = await response.json();
            if (data.data && !data.error) {
                return data.data; // Return the message data
            } else {
                console.error('Error sending message:', data.error);
                throw new Error(data.error || 'Failed to send message');
            }
        },
        
        async closeConversation() {
            if (typeof confirmAction === 'function') {
                const confirmed = await confirmAction('Đóng cuộc hội thoại?', 'Bạn có chắc muốn đóng cuộc hội thoại này?');
                if (!confirmed) return;
            } else if (!confirm('Bạn có chắc muốn đóng cuộc hội thoại này?')) {
                return;
            }
            
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${this.selectedConversation.id}/close`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.selectedConversation.status = 'CLOSED';
                    // Update conversation in list without reload
                    this.updateConversationStatus(this.selectedConversation.id, 'CLOSED');
                    if (typeof showSuccess === 'function') {
                        showSuccess('Đã đóng cuộc hội thoại');
                    }
                } else {
                    console.error('Error closing conversation:', data.error);
                    if (typeof showError === 'function') {
                        showError('Không thể đóng cuộc hội thoại: ' + data.error);
                    }
                }
            } catch (error) {
                console.error('Error closing conversation:', error);
            }
        },
        
        async reopenConversation() {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${this.selectedConversation.id}/reopen`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.selectedConversation.status = 'ASSIGNED';
                    // Update conversation in list without reload
                    this.updateConversationStatus(this.selectedConversation.id, 'ASSIGNED');
                } else {
                    console.error('Error reopening conversation:', data.error);
                }
            } catch (error) {
                console.error('Error reopening conversation:', error);
            }
        },
        
        async returnToAi() {
            console.log('🤖 returnToAi() called');
            console.log('🤖 selectedConversation:', this.selectedConversation);
            
            // PREVENT DUPLICATE CALLS
            if (this.returningToAi) {
                console.log('🤖 Already processing AI return, ignoring duplicate call');
                return;
            }
            
            if (!this.selectedConversation) {
                console.error('❌ No conversation selected');
                if (typeof showWarning === 'function') {
                    showWarning('Chưa chọn cuộc hội thoại');
                }
                return;
            }
            
            // Set flag to prevent duplicate calls
            this.returningToAi = true;
            
            let confirmed = false;
            if (typeof confirmAction === 'function') {
                confirmed = await confirmAction('Trao lại cho AI?', 'Trao lại cuộc hội thoại này cho Hoa AI?\n\nSau 30 giây, nếu khách không nhắn tin thì AI sẽ tiếp tục hỗ trợ. Nếu khách nhắn tin trong 30 giây, bạn sẽ tiếp tục xử lý.');
            } else {
                confirmed = confirm('Trao lại cuộc hội thoại này cho Hoa AI?\n\nSau 30 giây, nếu khách không nhắn tin thì AI sẽ tiếp tục hỗ trợ. Nếu khách nhắn tin trong 30 giây, bạn sẽ tiếp tục xử lý.');
            }
            
            if (!confirmed) {
                console.log('🤖 User cancelled AI return');
                this.returningToAi = false; // Reset flag
                return;
            }
            
            console.log('🤖 Starting AI return process...');
            
            try {
                const csrf = this.getCsrfToken();
                console.log('🤖 CSRF token:', csrf);
                
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const url = `/api/staff/conversations/${this.selectedConversation.id}/return-to-ai`;
                console.log('🤖 API URL:', url);
                console.log('🤖 Headers:', headers);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers
                });
                
                console.log('🤖 Response status:', response.status);
                console.log('🤖 Response ok:', response.ok);
                
                const data = await response.json();
                console.log('🤖 Response data:', data);
                
                if (response.ok && (data.data || data.message)) {
                    this.showNotification('✅ Sẽ trao lại cho Hoa AI sau 30 giây nếu khách không nhắn tin');
                    console.log('✅ Queued conversation for AI return');
                } else {
                    console.error('❌ Error returning to AI:', data.error || data.message);
                    if (typeof showError === 'function') {
                        showError('Không thể trao lại cho AI: ' + (data.error || data.message || 'Unknown error'));
                    }
                }
            } catch (error) {
                console.error('❌ Exception in returnToAi:', error);
                if (typeof showError === 'function') {
                    showError('Lỗi khi trao lại cho AI: ' + error.message);
                }
            } finally {
                // ALWAYS reset flag to allow future calls
                this.returningToAi = false;
                console.log('🤖 Reset returningToAi flag');
            }
        },
        
        async searchConversations() {
            if (!this.searchQuery.trim()) {
                // Don't reload if we already have conversations loaded
                if (this.conversations.length === 0) {
                    await this.loadConversations();
                }
                return;
            }
            
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/search?q=${encodeURIComponent(this.searchQuery)}`, {
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.conversations = data.data || [];
                } else {
                    console.error('Error searching conversations:', data.error);
                }
            } catch (error) {
                console.error('Error searching conversations:', error);
            }
        },
        
        async assignConversation(conversationId) {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${conversationId}/assign`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    // Update conversation status without reload
                    this.updateConversationStatus(conversationId, 'ASSIGNED');
                    if (typeof showSuccess === 'function') {
                        showSuccess('Đã nhận cuộc hội thoại');
                    }
                } else {
                    console.error('Error assigning conversation:', data.error);
                    if (typeof showError === 'function') {
                        showError('Không thể nhận cuộc hội thoại: ' + data.error);
                    }
                }
            } catch (error) {
                console.error('Error assigning conversation:', error);
                if (typeof showError === 'function') {
                    showError('Không thể nhận cuộc hội thoại');
                }
            }
        },
        
        handleTyping() {
            if (this.typingTimeout) {
                clearTimeout(this.typingTimeout);
            }
            
            // Validate required data before sending
            if (!this.stompClient || !this.stompClient.connected || !this.selectedConversation || !this.staffId) {
                console.warn('Cannot send typing indicator: missing required data', {
                    connected: this.stompClient?.connected,
                    selectedConversation: !!this.selectedConversation,
                    staffId: this.staffId
                });
                return;
            }
            
            try {
                const typingData = {
                    conversationId: this.selectedConversation.id.toString(),
                    userId: this.staffId.toString(), // Ensure it's a string
                    userName: 'Staff'
                };
                
                console.debug('Sending typing indicator:', typingData);
                
                this.stompClient.send('/app/chat.typing', {}, JSON.stringify(typingData));
            } catch (error) {
                console.error('Error sending typing indicator:', error);
            }
            
            this.typingTimeout = setTimeout(() => {
                // Typing stopped
            }, 1000);
        },
        
        connectWebSocket() {
            try {
                const socket = new SockJS('/ws');
                this.stompClient = Stomp.over(socket);
                this.stompClient.debug = null;
                
                this.stompClient.connect({}, (frame) => {
                    console.log('WebSocket connected for chat');
                    
                    // Subscribe to handoff queue updates to refresh conversations list
                    try {
                        this.stompClient.subscribe('/topic/handoff-queue', (message) => {
                            try {
                                const notification = JSON.parse(message.body);
                                console.log('📥 Handoff queue update:', notification);
                            } catch (e) { /* noop */ }
                            // Always refresh conversations so staff sees new handoff immediately
                            this.loadConversations();
                            // Optionally also refresh any handoff-specific list if present
                            if (typeof this.loadHandoffQueue === 'function') {
                                this.loadHandoffQueue();
                            }
                            if (typeof this.showNotification === 'function') {
                                this.showNotification('Có cuộc hội thoại mới cần hỗ trợ');
                            }
                        });
                    } catch (e) {
                        console.error('Error subscribing to handoff-queue:', e);
                    }

                    // Subscribe to new conversation notifications
                    this.stompClient.subscribe('/topic/notifications', (message) => {
                        const notification = JSON.parse(message.body);
                        if (notification.type === 'new_conversation') {
                            // Only reload if we don't have conversations loaded yet
                            if (this.conversations.length === 0) {
                                this.loadConversations();
                            }
                            this.showNotification(notification.message);
                        }
                    });
                    
                    // Subscribe to conversation updates (like Messenger/Zalo)
                    this.stompClient.subscribe('/topic/conversation-updates', (message) => {
                        const update = JSON.parse(message.body);
                        this.handleConversationUpdate(update);
                    });
                    
                    // Subscribe to general chat updates
                    this.stompClient.subscribe('/topic/chat-updates', (message) => {
                        const update = JSON.parse(message.body);
                        this.handleChatUpdate(update);
                    });
                    
                    // Subscribe to all chat messages for staff
                    this.stompClient.subscribe('/topic/chat/staff', (message) => {
                        const msg = JSON.parse(message.body);
                        console.log('Received message for staff:', msg);
                        this.handleIncomingMessage(msg);
                    });
                    
                }, (error) => {
                    console.error('WebSocket error:', error);
                    // Exponential backoff for reconnection
                    setTimeout(() => this.connectWebSocket(), 5000);
                });
            } catch (error) {
                console.error('Error creating WebSocket connection:', error);
            }
        },
        
        setupRealTimeUpdates() {
            // Setup periodic health check for WebSocket connection
            setInterval(() => {
                if (!this.stompClient || !this.stompClient.connected) {
                    console.log('WebSocket disconnected, attempting to reconnect...');
                    this.connectWebSocket();
                }
            }, 10000); // Check every 10 seconds
            
            // Setup periodic conversation list refresh (much less frequent)
            setInterval(() => {
                // Only refresh if no conversation is selected and no recent activity
                if (!this.selectedConversation) {
                    this.loadConversations();
                }
            }, 300000); // Refresh every 5 minutes only when no conversation selected
        },
        
        setupProcessedMessagesCleanup() {
            // Cleanup processed message flags every 5 minutes to prevent memory leak
            setInterval(() => {
                const keys = Object.keys(this).filter(key => key.startsWith('processed_'));
                if (keys.length > 100) { // Only cleanup if we have many processed messages
                    keys.forEach(key => {
                        delete this[key];
                    });
                    console.log(`🧹 Cleaned up ${keys.length} processed message flags`);
                }
            }, 300000); // Cleanup every 5 minutes
        },
        
        handleConversationUpdate(update) {
            // Update conversation in the list without full reload (like Messenger/Zalo)
            console.log('🔄 handleConversationUpdate called:', update);
            console.log('🔄 Update type:', update.updateType);
            console.log('🔄 Update data:', update.data);
            
            const index = this.conversations.findIndex(c => c.id === update.conversationId);
            if (index !== -1) {
                console.log('🔄 Found conversation at index:', index);
                console.log('🔄 Current conversation ID:', this.conversations[index].id);
                
                // ⚠️ IMPORTANT: Do NOT spread update.data directly!
                // update.data might be a ChatMessageDTO with its own 'id' field (message ID)
                // which would overwrite the conversation ID!
                
                // Instead, only update specific fields we know are safe
                if (update.updateType === 'new_message' && update.data) {
                    // Update last message info from ChatMessageDTO
                    this.conversations[index].lastMessageContent = update.data.content;
                    this.conversations[index].lastMessageSenderId = update.data.senderId;
                    this.conversations[index].lastMessageAt = update.data.sentAt;
                    
                    console.log('🔄 Updated last message info');
                    console.log('🔄 Conversation ID after update:', this.conversations[index].id);
                    
                    // Move updated conversation to top (like Messenger/Zalo)
                    if (index > 0) {
                        const updatedConv = this.conversations.splice(index, 1)[0];
                        this.conversations.unshift(updatedConv);
                        console.log('🔄 Moved conversation to top');
                    }
                } else {
                    // For other update types, safely update only known conversation fields
                    if (update.data.status) {
                        this.conversations[index].status = update.data.status;
                    }
                    if (update.data.priority) {
                        this.conversations[index].priority = update.data.priority;
                    }
                    console.log('🔄 Updated conversation status/priority');
                }
                
                console.log('🔄 Final conversation ID:', this.conversations[index].id);
            } else if (update.updateType === 'new_conversation') {
                console.log('🔄 New conversation, checking if exists...');
                // Only reload conversations if it's truly a new conversation
                // Don't reload if it's just an update to existing conversation
                // Check if conversation already exists in our list
                const exists = this.conversations.some(c => c.id === update.conversationId);
                if (!exists) {
                    console.log('🔄 Conversation does not exist, loading conversations...');
                    this.loadConversations();
                } else {
                    console.log('🔄 Conversation already exists, skipping reload');
                }
            }
        },
        
        handleChatUpdate(update) {
            // Handle general chat updates (like Messenger/Zalo)
            console.log('📢 handleChatUpdate called:', update);
            switch (update.type) {
                case 'message_sent':
                    // ⚠️ REMOVED: Don't call updateConversationInList here!
                    // This causes duplicate processing because the same message is already processed
                    // in handleIncomingMessage from /topic/chat/staff subscription
                    console.log('📢 Message sent update received, but skipping to avoid duplicate processing');
                    console.log('📢 Message is already processed in handleIncomingMessage');
                    break;
                case 'conversation_status_changed':
                    // Update conversation status
                    this.handleConversationUpdate(update);
                    break;
                case 'user_typing':
                    // Handle typing indicators
                    this.handleTypingIndicator(update);
                    break;
                default:
                    console.log('Unknown chat update type:', update.type);
            }
        },
        
        handleTypingIndicator(update) {
            // Show typing indicator (like Messenger/Zalo)
            if (this.selectedConversation && update.conversationId === this.selectedConversation.id) {
                this.isTyping = true;
                setTimeout(() => {
                    this.isTyping = false;
                }, 3000);
            }
        },
        
        updateConversationInList(conversationId, messageData, isViewingConversation = false) {
            console.log('📝 updateConversationInList called:', { 
                conversationId, 
                messageData, 
                staffId: this.staffId,
                isViewingConversation 
            });
            
            // Update specific conversation without reloading entire list
            const index = this.conversations.findIndex(c => c.id == conversationId);
            console.log('📝 Found conversation at index:', index);
            
            if (index !== -1) {
                console.log('📝 Current conversation ID:', this.conversations[index].id);
                console.log('📝 Current unread count:', this.conversations[index].unreadCount);
                
                // ⚠️ IMPORTANT: Preserve conversation ID!
                const originalConvId = this.conversations[index].id;
                
                // Update last message info
                this.conversations[index].lastMessageContent = messageData.content;
                this.conversations[index].lastMessageSenderId = messageData.senderId;
                this.conversations[index].lastMessageAt = messageData.sentAt;
                
                console.log('📝 Message from:', messageData.senderId, 'Staff ID:', this.staffId);
                console.log('📝 Is from customer:', messageData.senderId != this.staffId);
                console.log('📝 Is viewing conversation:', isViewingConversation);
                
                // Update unread count logic:
                // - If message is from customer AND staff is NOT viewing: increase unread count
                // - If message is from customer AND staff IS viewing: don't increase (will be marked as read)
                // - If message is from staff: reset to 0
                if (messageData.senderId != this.staffId) {
                    // Message from customer
                    if (!isViewingConversation) {
                        // Staff is NOT viewing this conversation - increase unread count
                        const oldCount = this.conversations[index].unreadCount || 0;
                        this.conversations[index].unreadCount = oldCount + 1;
                        console.log(`✅ Increased unread count for conversation ${conversationId}: ${oldCount} -> ${this.conversations[index].unreadCount}`);
                        
                        // Alpine.js automatically updates UI (reactive)
                    } else {
                        // Staff IS viewing this conversation - don't increase, will be marked as read
                        console.log(`📝 Staff is viewing conversation ${conversationId}, not increasing unread count (will be marked as read)`);
                    }
                } else {
                    // Message from staff - reset unread count to 0 (staff just replied)
                    console.log(`📝 Message from staff, resetting unread count to 0`);
                    this.conversations[index].unreadCount = 0;
                    // Alpine.js automatically updates UI (reactive)
                }
                
                // ⚠️ CRITICAL: Ensure conversation ID is preserved after updates
                this.conversations[index].id = originalConvId;
                console.log('📝 Preserved conversation ID:', this.conversations[index].id);
                console.log('📝 Final unread count:', this.conversations[index].unreadCount);
                
                // Move conversation to top if it has a new message
                if (index > 0) {
                    const updatedConv = this.conversations.splice(index, 1)[0];
                    // Double-check ID is preserved
                    updatedConv.id = originalConvId;
                    this.conversations.unshift(updatedConv);
                    console.log('✅ Moved conversation to top with ID:', updatedConv.id);
                }
            } else {
                console.log('❌ Conversation not found in list:', conversationId);
            }
        },
        
        updateConversationStatus(conversationId, newStatus) {
            // Update conversation status without reloading entire list
            const index = this.conversations.findIndex(c => c.id === conversationId);
            if (index !== -1) {
                this.conversations[index].status = newStatus;
                
                // Update selected conversation if it's the same
                if (this.selectedConversation && this.selectedConversation.id === conversationId) {
                    this.selectedConversation.status = newStatus;
                }
            }
        },
        
        updateUnreadCountAfterStaffMessage() {
            // When staff sends a message, reset unread count for this conversation
            if (this.selectedConversation) {
                const index = this.conversations.findIndex(c => c.id === this.selectedConversation.id);
                if (index !== -1) {
                    // Reset unread count to 0 since staff just replied
                    this.conversations[index].unreadCount = 0;
                }
            }
        },
        
        updateUnreadCountAfterMarkAsRead(conversationId) {
            // When staff marks conversation as read, reset unread count
            const index = this.conversations.findIndex(c => c.id == conversationId);
            if (index !== -1) {
                // Reset unread count to 0 since staff marked as read
                const oldCount = this.conversations[index].unreadCount;
                this.conversations[index].unreadCount = 0;
                console.log(`✅ Reset unread count for conversation ${conversationId}: ${oldCount} -> 0`);
                // Alpine.js automatically updates UI (reactive)
            } else {
                console.log(`❌ Conversation ${conversationId} not found when trying to reset unread count`);
            }
        },
        
        forceUpdateUI() {
            // Alpine.js automatically updates UI - this method is no longer needed
            console.log('🔄 UI auto-updates (Alpine reactive)');
        },
        
        // Debug method to test conversation selection
        debugSelectConversation(convId) {
            console.log('🔍 Debug: Testing conversation selection for ID:', convId);
            const conv = this.conversations.find(c => c.id == convId);
            if (conv) {
                console.log('🔍 Found conversation:', conv);
                this.selectConversation(conv);
            } else {
                console.log('🔍 Conversation not found in list');
                console.log('🔍 Available conversations:', this.conversations.map(c => ({ id: c.id, name: c.customerName })));
            }
        },
        
        // Global method to select conversation by ID (called from notifications)
        selectConversationById(conversationId) {
            console.log('🔔 Selecting conversation from notification:', conversationId);
            
            // Find conversation in list
            const conv = this.conversations.find(c => c.id == conversationId);
            
            if (conv) {
                // Select the conversation
                this.selectConversation(conv);
                
                // Scroll to top of conversation list to show selected
                const convList = document.querySelector('.chat-scrollbar');
                if (convList) {
                    convList.scrollTop = 0;
                }
            } else {
                // Conversation not in list yet, load it
                console.log('🔔 Conversation not in list, loading conversations...');
                this.loadConversations().then(() => {
                    const foundConv = this.conversations.find(c => c.id == conversationId);
                    if (foundConv) {
                        this.selectConversation(foundConv);
                    } else {
                        console.error('❌ Conversation still not found after reload:', conversationId);
                        // Show error to user
                        if (typeof showError === 'function') {
                            showError('Không tìm thấy cuộc hội thoại này');
                        }
                    }
                });
            }
        },
        
        showNotification(message) {
            // Create notification element with better styling
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center space-x-2 animate-pulse';
            notification.innerHTML = `
                <i class="fas fa-bell"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notification);
            
            // Add sound notification (optional)
            try {
                const audio = new Audio('/sounds/notification.mp3');
                audio.play().catch(() => {
                    // Ignore if audio file doesn't exist
                });
            } catch (e) {
                // Ignore audio errors
            }
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 5000);
        },
        
        scrollToBottom() {
            this.$nextTick(() => {
                const container = document.getElementById('messagesContainer');
                if (container) {
                    // Force scroll to bottom immediately
                    container.scrollTop = container.scrollHeight;
                    
                    // Also try smooth scroll as backup
                    setTimeout(() => {
                        container.scrollTo({
                            top: container.scrollHeight,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
            });
        },
        
        handleScroll(event) {
            // Load more messages if scrolled to top
            if (event.target.scrollTop === 0 && !this.loadingMessages) {
                // TODO: Load more messages
            }
        },
        
        formatTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Vừa xong';
            if (diff < 3600000) return Math.floor(diff / 60000) + ' phút';
            if (diff < 86400000) return Math.floor(diff / 3600000) + ' giờ';
            return date.toLocaleDateString('vi-VN');
        },
        
        formatMessageTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            return date.toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'});
        },
        
        formatDateTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            return date.toLocaleString('vi-VN');
        },
        
        parseMarkdown(text) {
            if (!text) return '';
            
            let html = text;
            
            // Fix escaped newlines from JSON (\\n -> actual newline)
            html = html.replace(/\\n/g, '\n');
            
            // Parse images first: ![alt](url) - using safer regex construction
            const imageRegex = new RegExp('!\\[([^\\]]*)\\]\\(([^)]+)\\)', 'g');
            html = html.replace(imageRegex, function(match, alt, url) {
                const safeAlt = alt.replace(/"/g, '&quot;');
                return '<img src="' + url + '" alt="' + safeAlt + '" class="max-w-full h-auto rounded-lg my-2 cursor-pointer message-image-hover" style="max-width: 200px;" onclick="window.open(\'' + url + '\', \'_blank\')" />';
            });
            
            // Parse links: [text](url) - using safer regex construction
            const linkRegex = new RegExp('\\[([^\\]]+)\\]\\(([^)]+)\\)', 'g');
            html = html.replace(linkRegex, function(match, text, url) {
                return '<a href="' + url + '" target="_blank" class="text-blue-600 hover:underline">' + text + '</a>';
            });
            
            // Parse bold: **text**
            const boldRegex = new RegExp('\\*\\*([^*]+)\\*\\*', 'g');
            html = html.replace(boldRegex, '<strong>$1</strong>');
            
            // Parse bullet lists: * item or - item
            const listRegex = new RegExp('^[\\*\\-]\\s+(.+)$', 'gm');
            html = html.replace(listRegex, '<li class="ml-4 mb-1">• $1</li>');
            
            // Wrap consecutive list items in ul
            const ulRegex = new RegExp('(<li[^>]*>.*?<\\/li>\\s*)+', 'g');
            html = html.replace(ulRegex, function(match) {
                return '<ul class="my-2 space-y-1">' + match + '</ul>';
            });
            
            // Parse numbered list items: 1️⃣, 2️⃣, etc.
            const emojiRegex = new RegExp('(\\d)️⃣', 'g');
            html = html.replace(emojiRegex, '<span class="font-bold text-pink-600">$1️⃣</span>');
            
            // Parse line breaks (but not inside lists)
            const brRegex = new RegExp('\\n(?![<ul>|<li>])', 'g');
            html = html.replace(brRegex, '<br>');
            
            // Clean up extra br tags around lists and images
            html = html.replace(/<br>\s*<ul>/g, '<ul>');
            html = html.replace(/<\/ul>\s*<br>/g, '</ul>');
            html = html.replace(/<br>\s*<img/g, '<img');
            html = html.replace(/\/>\s*<br>/g, '/>');
            
            return html;
        },
        
        getStatusText(status) {
            const map = {
                'OPEN': 'Chưa xử lý',
                'ASSIGNED': 'Đang xử lý',
                'CLOSED': 'Đã đóng'
            };
            return map[status] || status;
        },
        
        getPriorityText(priority) {
            const map = {
                'LOW': 'Thấp',
                'NORMAL': 'Bình thường',
                'HIGH': 'Cao',
                'URGENT': 'Khẩn cấp'
            };
            return map[priority] || priority;
        },
        
        // Helper functions for optimistic messages
        replaceOptimisticMessage(optimisticId, realMessage) {
            const index = this.messages.findIndex(m => m.id === optimisticId);
            if (index !== -1) {
                this.messages[index] = realMessage;
                console.log('✅ Replaced optimistic message with real message');
            }
        },
        
        removeOptimisticMessage(optimisticId) {
            const index = this.messages.findIndex(m => m.id === optimisticId);
            if (index !== -1) {
                this.messages.splice(index, 1);
                console.log('❌ Removed failed optimistic message');
            }
        }
    }
}

</script>
