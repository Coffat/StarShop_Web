<!-- Staff Chat Interface Content -->
<div class="h-full flex flex-col lg:flex-row gap-4" x-data="staffChat()" x-init="init()">
    
    <!-- Left Sidebar - Conversations List -->
    <div class="lg:w-80 flex flex-col bg-white rounded-lg shadow overflow-hidden">
        <!-- Search -->
        <div class="p-4 border-b border-gray-200">
            <div class="relative">
                <input type="text" 
                       x-model="searchQuery"
                       @input="searchConversations()"
                       placeholder="T√¨m ki·∫øm kh√°ch h√†ng..."
                       class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent">
                <i class="fas fa-search absolute left-3 top-3 text-gray-400"></i>
            </div>
        </div>
        
        <!-- Conversations List -->
        <div class="flex-1 overflow-y-auto chat-scrollbar">
            <template x-if="loading">
                <div class="flex items-center justify-center p-8">
                    <div class="spinner"></div>
                </div>
            </template>
            
            <template x-if="!loading && conversations.length === 0">
                <div class="text-center py-12 px-4">
                    <i class="fas fa-comments text-gray-300 text-5xl mb-4"></i>
                    <p class="text-gray-500">Ch∆∞a c√≥ cu·ªôc h·ªôi tho·∫°i n√†o</p>
                </div>
            </template>
            
            <template x-for="conv in conversations" :key="conv.id.toString()">
                <div @click="selectConversation(conv)" 
                     @click.prevent="selectConversation(conv)"
                     :class="{'bg-primary-50 border-l-4 border-primary-500': selectedConversation && selectedConversation.id === conv.id}"
                     class="conversation-item p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition-colors">
                    <div class="flex items-start space-x-3">
                        <!-- Avatar -->
                        <div class="flex-shrink-0 relative">
                            <template x-if="conv.customerAvatar">
                                <img :src="conv.customerAvatar" :alt="conv.customerName" 
                                     class="w-12 h-12 rounded-full object-cover">
                            </template>
                            <template x-if="!conv.customerAvatar">
                                <div class="w-12 h-12 rounded-full bg-primary-500 flex items-center justify-center">
                                    <span class="text-white font-semibold text-lg" x-text="conv.customerName.charAt(0)"></span>
                                </div>
                            </template>
                            <template x-if="conv.unreadCount > 0">
                                <span class="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full w-5 h-5 flex items-center justify-center"
                                      x-text="conv.unreadCount"></span>
                            </template>
                        </div>
                        
                        <!-- Info -->
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center justify-between mb-1">
                                <h4 class="font-semibold text-gray-900 truncate" x-text="conv.customerName"></h4>
                                <div class="flex items-center space-x-2">
                                    <span class="text-xs text-gray-500" x-text="formatTime(conv.lastMessageAt)"></span>
                                    <template x-if="conv.status === 'OPEN'">
                                        <button @click.stop="assignConversation(conv.id)" 
                                                class="px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors">
                                            <i class="fas fa-hand-paper mr-1"></i>Nh·∫≠n
                                        </button>
                                    </template>
                                </div>
                            </div>
                            <p class="text-sm text-gray-600 truncate" x-text="conv.lastMessageContent || 'Ch∆∞a c√≥ tin nh·∫Øn'"></p>
                            <div class="flex items-center space-x-2 mt-1">
                                <template x-if="conv.status === 'OPEN'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-yellow-100 text-yellow-800">
                                        <i class="fas fa-clock mr-1"></i> Ch∆∞a x·ª≠ l√Ω
                                    </span>
                                </template>
                                <template x-if="conv.status === 'ASSIGNED'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                                        <i class="fas fa-user mr-1"></i> ƒê√£ nh·∫≠n
                                    </span>
                                </template>
                                <template x-if="conv.priority === 'HIGH'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-100 text-orange-800">
                                        <i class="fas fa-exclamation-circle mr-1"></i> Cao
                                    </span>
                                </template>
                                <template x-if="conv.priority === 'URGENT'">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                                        <i class="fas fa-exclamation-triangle mr-1"></i> Kh·∫©n c·∫•p
                                    </span>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
    
    <!-- Main Chat Area -->
    <div class="flex-1 flex flex-col bg-white rounded-lg shadow overflow-hidden">
        <template x-if="!selectedConversation">
            <div class="flex-1 flex items-center justify-center">
                <div class="text-center">
                    <i class="fas fa-comments text-gray-300 text-6xl mb-4"></i>
                    <p class="text-gray-500 text-lg">Ch·ªçn cu·ªôc h·ªôi tho·∫°i ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                </div>
            </div>
        </template>
        
        <template x-if="selectedConversation">
            <div class="flex-1 flex flex-col h-full">
                <!-- Chat Header -->
                <div class="px-6 py-4 border-b border-gray-200 bg-gradient-to-r from-primary-50 to-pink-50">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <template x-if="selectedConversation.customerAvatar">
                                <img :src="selectedConversation.customerAvatar" 
                                     :alt="selectedConversation.customerName" 
                                     class="w-10 h-10 rounded-full object-cover">
                            </template>
                            <template x-if="!selectedConversation.customerAvatar">
                                <div class="w-10 h-10 rounded-full bg-primary-500 flex items-center justify-center">
                                    <span class="text-white font-semibold" x-text="selectedConversation.customerName.charAt(0)"></span>
                                </div>
                            </template>
                            <div>
                                <h3 class="font-semibold text-gray-900" x-text="selectedConversation.customerName"></h3>
                                <p class="text-sm text-gray-600" x-text="selectedConversation.customerEmail"></p>
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            
                            <!-- N√∫t AI - trao l·∫°i cho AI sau 30s -->
                            <template x-if="selectedConversation && selectedConversation.status === 'ASSIGNED' && selectedConversation.assignedStaffId && Number(selectedConversation.assignedStaffId) === Number(staffId)">
                                <button @click="returnToAi()"
                                        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors shadow-md"
                                        title="Trao l·∫°i cho AI sau 30 gi√¢y n·∫øu kh√°ch kh√¥ng nh·∫Øn tin"
                                        :disabled="returningToAi">
                                    <template x-if="!returningToAi">
                                        <span><i class="fas fa-robot mr-2"></i>AI</span>
                                    </template>
                                    <template x-if="returningToAi">
                                        <span><i class="fas fa-spinner fa-spin mr-2"></i>ƒêang x·ª≠ l√Ω...</span>
                                    </template>
                                </button>
                            </template>
                            
                            <!-- N√∫t ƒê√≥ng -->
                            <template x-if="selectedConversation.status !== 'CLOSED'">
                                <button @click="closeConversation()" 
                                        class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                                    <i class="fas fa-times mr-2"></i>ƒê√≥ng
                                </button>
                            </template>
                            
                            <!-- N√∫t M·ªü l·∫°i -->
                            <template x-if="selectedConversation.status === 'CLOSED'">
                                <button @click="reopenConversation()" 
                                        class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                                    <i class="fas fa-redo mr-2"></i>M·ªü l·∫°i
                                </button>
                            </template>
                        </div>
                    </div>
                </div>
                
                <!-- Messages Area -->
                <div class="flex-1 overflow-y-auto p-4 bg-gradient-to-b from-gray-50 to-white chat-scrollbar" 
                     id="messagesContainer"
                     @scroll="handleScroll"
                     style="height: calc(100vh - 300px); max-height: calc(100vh - 300px); min-height: 400px;">
                    <template x-if="loadingMessages">
                        <div class="flex items-center justify-center p-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-pink-500"></div>
                        </div>
                    </template>
                    
                    <template x-for="msg in messages" :key="msg.id.toString()">
                        <div>
                            <!-- System Message (Center) -->
                            <template x-if="msg.messageType === 'SYSTEM'">
                                <div class="flex justify-center w-full mb-4">
                                    <div class="bg-yellow-100 text-yellow-800 px-4 py-2 rounded-full text-sm font-medium shadow-sm">
                                        <i class="fas fa-info-circle mr-2"></i>
                                        <span x-text="msg.content"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Staff Message (Right) -->
                            <template x-if="msg.senderId === staffId && msg.messageType !== 'SYSTEM'">
                                <div class="flex justify-end mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="flex flex-col items-end">
                                            <div class="bg-gradient-to-r from-pink-500 to-purple-600 text-white px-4 py-3 rounded-2xl rounded-br-md shadow-lg">
                                                <p class="text-sm leading-relaxed" x-text="msg.content"></p>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-pink-500 to-purple-600 flex items-center justify-center text-white text-sm font-semibold">
                                            S
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- AI Message (Left with special styling) -->
                            <template x-if="msg.isAiGenerated && msg.senderId !== staffId">
                                <div class="flex justify-start mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-purple-500 to-indigo-600 flex items-center justify-center text-white text-sm font-semibold">
                                            ü§ñ
                                        </div>
                                        <div class="flex flex-col items-start">
                                            <div class="bg-gradient-to-r from-purple-100 to-indigo-100 text-purple-800 px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-purple-200">
                                                <div class="text-sm leading-relaxed" x-html="parseMarkdown(msg.content)"></div>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Customer Message (Left) -->
                            <template x-if="msg.senderId !== staffId && msg.messageType === 'TEXT' && !msg.isAiGenerated">
                                <div class="flex justify-start mb-4">
                                    <div class="flex items-end space-x-2 max-w-xs lg:max-w-md">
                                        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center text-white text-sm font-semibold">
                                            <span x-text="selectedConversation.customerName.charAt(0)"></span>
                                        </div>
                                        <div class="flex flex-col items-start">
                                            <div class="bg-white text-gray-800 px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-gray-100">
                                                <p class="text-sm leading-relaxed" x-text="msg.content"></p>
                                            </div>
                                            <span class="text-xs text-gray-500 mt-1 px-2" x-text="formatMessageTime(msg.sentAt)"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                    
                    <!-- Typing Indicator -->
                    <template x-if="isTyping">
                        <div class="flex justify-start mb-4">
                            <div class="flex items-end space-x-2">
                                <div class="w-8 h-8 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center text-white text-sm font-semibold">
                                    <span x-text="selectedConversation.customerName.charAt(0)"></span>
                                </div>
                                <div class="bg-white px-4 py-3 rounded-2xl rounded-bl-md shadow-lg border border-gray-100">
                                    <div class="flex space-x-1">
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Message Input -->
                <div class="p-4 bg-white border-t border-gray-200 flex-shrink-0">
                    <div class="flex items-end space-x-3">
                        <div class="flex-1 relative">
                            <textarea x-model="messageText"
                                     @keydown.enter.prevent="sendMessage()"
                                     @input="handleTyping()"
                                     placeholder="Nh·∫≠p tin nh·∫Øn..."
                                     rows="1"
                                     class="w-full px-4 py-3 pr-12 border border-gray-300 rounded-2xl resize-none focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-200 bg-gray-50 focus:bg-white"
                                     style="min-height: 44px; max-height: 120px;"></textarea>
                            <div class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm">
                                <i class="fas fa-paperclip"></i>
                            </div>
                        </div>
                        <button @click="sendMessage()"
                                :disabled="!messageText.trim() || sendingMessage"
                                class="w-12 h-12 bg-gradient-to-r from-pink-500 to-purple-600 text-white rounded-full flex items-center justify-center transition-all duration-200 hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
                            <template x-if="!sendingMessage">
                                <i class="fas fa-paper-plane text-lg"></i>
                            </template>
                            <template x-if="sendingMessage">
                                <i class="fas fa-spinner fa-spin text-lg"></i>
                            </template>
                        </button>
                    </div>
                </div>
            </div>
        </template>
    </div>
    
    <!-- Right Sidebar - Customer Info (Hidden on mobile) -->
    <div class="hidden xl:block w-80 bg-white rounded-lg shadow p-6" x-show="selectedConversation">
        <h3 class="text-lg font-semibold text-gray-900 mb-4">
            <i class="fas fa-info-circle mr-2 text-primary-600"></i>
            Th√¥ng tin kh√°ch h√†ng
        </h3>
        
        <template x-if="selectedConversation">
            <div class="space-y-4">
                <!-- Customer Details -->
                <div class="border-b border-gray-200 pb-4">
                    <div class="text-center mb-4">
                        <template x-if="selectedConversation.customerAvatar">
                            <img :src="selectedConversation.customerAvatar" 
                                 :alt="selectedConversation.customerName" 
                                 class="w-20 h-20 rounded-full object-cover mx-auto mb-3">
                        </template>
                        <template x-if="!selectedConversation.customerAvatar">
                            <div class="w-20 h-20 rounded-full bg-primary-500 flex items-center justify-center mx-auto mb-3">
                                <span class="text-white font-bold text-2xl" x-text="selectedConversation.customerName.charAt(0)"></span>
                            </div>
                        </template>
                        <h4 class="font-semibold text-gray-900" x-text="selectedConversation.customerName"></h4>
                    </div>
                    
                    <div class="space-y-2 text-sm">
                        <div class="flex items-center text-gray-600">
                            <i class="fas fa-envelope w-6"></i>
                            <span x-text="selectedConversation.customerEmail"></span>
                        </div>
                        <template x-if="selectedConversation.customerPhone">
                            <div class="flex items-center text-gray-600">
                                <i class="fas fa-phone w-6"></i>
                                <span x-text="selectedConversation.customerPhone"></span>
                            </div>
                        </template>
                    </div>
                </div>
                
                <!-- Conversation Info -->
                <div class="border-b border-gray-200 pb-4">
                    <h5 class="font-semibold text-gray-900 mb-3">Th√¥ng tin cu·ªôc h·ªôi tho·∫°i</h5>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Tr·∫°ng th√°i:</span>
                            <span class="font-medium" x-text="getStatusText(selectedConversation.status)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">ƒê·ªô ∆∞u ti√™n:</span>
                            <span class="font-medium" x-text="getPriorityText(selectedConversation.priority)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">B·∫Øt ƒë·∫ßu:</span>
                            <span x-text="formatDateTime(selectedConversation.createdAt)"></span>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Actions -->
                <div>
                    <h5 class="font-semibold text-gray-900 mb-3">Thao t√°c nhanh</h5>
                    <div class="space-y-2">
                        <button class="w-full px-4 py-2 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 transition-colors text-sm">
                            <i class="fas fa-user mr-2"></i>Xem h·ªì s∆° kh√°ch h√†ng
                        </button>
                        <button class="w-full px-4 py-2 bg-green-50 text-green-700 rounded-lg hover:bg-green-100 transition-colors text-sm">
                            <i class="fas fa-shopping-cart mr-2"></i>Xem ƒë∆°n h√†ng
                        </button>
                    </div>
                </div>
            </div>
        </template>
    </div>
</div>

<script th:inline="none">
function staffChat() {
    return {
        staffId: Number(/*[[${staffId}]]*/ 10), // Force number type
        conversations: [],
        selectedConversation: null,
        messages: [],
        messageText: '',
        searchQuery: '',
        loading: false,
        loadingMessages: false,
        sendingMessage: false,
        returningToAi: false, // Flag to prevent duplicate AI return calls
        isTyping: false,
        typingTimeout: null,
        stompClient: null,
        currentSubscription: null,
        
        async init() {
            await this.loadConversations();
            this.connectWebSocket();
            
            // Check if conversation ID in URL
            const urlParams = new URLSearchParams(window.location.search);
            const convId = urlParams.get('conversation');
            if (convId) {
                const conv = this.conversations.find(c => c.id == convId);
                if (conv) {
                    await this.selectConversation(conv);
                } else {
                }
            }
            
            // Setup real-time updates like Messenger/Zalo
            this.setupRealTimeUpdates();
            
            // Cleanup processed messages periodically to prevent memory leak
            this.setupProcessedMessagesCleanup();
            
        },
        
        async loadConversations() {
            this.loading = true;
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch('/api/staff/conversations?page=0&size=50', {
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.conversations = data.data || [];
                    // Debug each conversation
                    this.conversations.forEach((conv, index) => {
                            status: conv.status
                        });
                    });
                } else {
                    console.error('‚ùå Error loading conversations:', data.error);
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Reload current conversation data (for UI updates after status changes)
         */
        async reloadCurrentConversation() {
            if (!this.selectedConversation) {
                return;
            }
            
            const conversationId = this.selectedConversation.id;
            
            try {
                // Reload conversation list to get updated data
                await this.loadConversations();
                
                // Find the updated conversation in the list
                const updatedConv = this.conversations.find(c => c.id == conversationId);
                
                if (updatedConv) {
                    // Update selectedConversation with new data
                    this.selectedConversation = updatedConv;
                } else {
                }
            } catch (error) {
                console.error('Error reloading conversation:', error);
            }
        },
        
        async selectConversation(conv) {
            
            // Validate conversation object
            if (!conv || !conv.id) {
                console.error('‚ùå Invalid conversation object:', conv);
                return;
            }
            
            // Ensure conversation ID is a number
            const conversationId = parseInt(conv.id);
            if (isNaN(conversationId)) {
                console.error('‚ùå Invalid conversation ID:', conv.id);
                return;
            }
            
            
            // Unsubscribe from previous conversation if exists
            if (this.currentSubscription && this.stompClient && this.stompClient.connected) {
                try {
                    this.currentSubscription.unsubscribe();
                } catch (error) {
                    console.error('Error unsubscribing from previous conversation:', error);
                }
            }
            
            // Create a clean conversation object with ALL fields to avoid reference issues
            this.selectedConversation = {
                id: conversationId,
                customerId: conv.customerId,
                customerName: conv.customerName,
                customerEmail: conv.customerEmail,
                customerPhone: conv.customerPhone,
                customerAvatar: conv.customerAvatar,
                lastMessage: conv.lastMessage,
                lastMessageAt: conv.lastMessageAt,
                lastMessageSender: conv.lastMessageSender,
                status: conv.status,
                priority: conv.priority,
                unreadCount: conv.unreadCount,
                createdAt: conv.createdAt,
                assignedStaffId: conv.assignedStaffId,
                assignedStaffName: conv.assignedStaffName
            };
            
            
            // Clear current messages before loading new ones
            this.messages = [];
            
            await this.loadMessages(conversationId);
            
            // Mark as read when staff opens the conversation
            this.markAsRead(conversationId);
            
            // Update unread count immediately in UI
            this.updateUnreadCountAfterMarkAsRead(conversationId);
            
            // Subscribe to this specific conversation
            if (this.stompClient && this.stompClient.connected) {
                try {
                    this.currentSubscription = this.stompClient.subscribe('/topic/chat/' + conversationId, (message) => {
                        const msg = JSON.parse(message.body);
                        this.handleIncomingMessage(msg);
                    });
                } catch (error) {
                    console.error('Error subscribing to conversation:', error);
                }
            }
            
            // Force scroll to bottom after loading messages
            setTimeout(() => {
                this.scrollToBottom();
            }, 200);
            
            // Also scroll after next tick
            this.$nextTick(() => {
                this.scrollToBottom();
            });
        },
        
        async loadMessages(conversationId) {
            console.log('üì• Loading messages for conversation:', conversationId);
            console.log('üì• ConversationId type:', typeof conversationId);
            
            // Validate conversationId
            if (!conversationId || isNaN(parseInt(conversationId))) {
                console.error('‚ùå Invalid conversationId for loadMessages:', conversationId);
                return;
            }
            
            // Ensure conversationId is a number
            const validConversationId = parseInt(conversationId);
            console.log('üì• Valid conversationId:', validConversationId);
            
            this.loadingMessages = true;
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const url = `/api/chat/conversations/${validConversationId}/messages?page=0&size=100`;
                console.log('üì• Fetching URL:', url);
                
                const response = await fetch(url, {
                    headers: headers
                });
                
                console.log('üì• Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('üì• Response data:', data);
                
                if (data.data && !data.error) {
                    this.messages = (data.data || []).reverse();
                    console.log('‚úÖ Loaded messages:', this.messages.length, 'messages');
                    console.log('‚úÖ Messages:', this.messages);
                    
                    // Force scroll to bottom after messages are loaded
                    setTimeout(() => {
                        this.scrollToBottom();
                    }, 100);
                } else {
                    console.error('‚ùå Error loading messages:', data.error);
                    this.messages = [];
                }
            } catch (error) {
                console.error('‚ùå Error loading messages:', error);
                this.messages = [];
            } finally {
                this.loadingMessages = false;
                
                // Final scroll to bottom after loading is complete
                setTimeout(() => {
                    this.scrollToBottom();
                }, 300);
            }
        },
        
        async sendMessage() {
            if (!this.messageText.trim() || !this.selectedConversation || this.sendingMessage) return;
            
            const messageContent = this.messageText.trim();
            this.sendingMessage = true;
            
            // Create optimistic message for immediate display
            const optimisticMessage = {
                id: 'temp_' + Date.now(), // Temporary ID
                conversationId: this.selectedConversation.id,
                senderId: this.staffId,
                receiverId: this.selectedConversation.customerId,
                content: messageContent,
                messageType: 'TEXT',
                sentAt: new Date().toISOString(),
                isRead: false,
                isOptimistic: true // Flag to identify optimistic messages
            };
            
            // Add optimistic message to UI immediately
            this.messages.push(optimisticMessage);
            this.messageText = '';
            
            // Scroll to bottom immediately
            this.$nextTick(() => this.scrollToBottom());
            
            try {
                const messageDTO = {
                    conversationId: this.selectedConversation.id.toString(),
                    senderId: this.staffId,
                    receiverId: this.selectedConversation.customerId,
                    content: messageContent,
                    messageType: 'TEXT'
                };
                
                let sentMessage = null;
                
                // Send via WebSocket if connected
                if (this.stompClient && this.stompClient.connected) {
                    try {
                        this.stompClient.send('/app/chat.send', {}, JSON.stringify(messageDTO));
                        // For WebSocket, we'll get the response via handleIncomingMessage
                        // The optimistic message will be replaced when we receive the real message
                    } catch (error) {
                        console.error('Error sending via WebSocket:', error);
                        // Fallback to REST API
                        sentMessage = await this.sendMessageViaRest(messageDTO);
                    }
                } else {
                    // Fallback to REST API
                    sentMessage = await this.sendMessageViaRest(messageDTO);
                }
                
                // If we got a response from REST API, replace optimistic message
                if (sentMessage) {
                    this.replaceOptimisticMessage(optimisticMessage.id, sentMessage);
                }
                
            } catch (error) {
                console.error('Error sending message:', error);
                // Remove optimistic message on error
                this.removeOptimisticMessage(optimisticMessage.id);
                if (typeof showError === 'function') {
                    showError('Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn');
                }
            } finally {
                this.sendingMessage = false;
            }
        },
        
        handleIncomingMessage(msg) {
            console.log('üîî handleIncomingMessage called:', msg);
            console.log('Current staffId:', this.staffId);
            console.log('Message senderId:', msg.senderId);
            console.log('Is from customer:', msg.senderId != this.staffId);
            console.log('Selected conversation:', this.selectedConversation);
            
            // ‚ö†Ô∏è CRITICAL: Prevent duplicate processing from multiple WebSocket subscriptions
            // Message can be received from both /topic/chat/{conversationId} and /topic/chat/staff
            const messageProcessedKey = `processed_${msg.id}`;
            if (this[messageProcessedKey]) {
                console.log('‚ö†Ô∏è Message already processed, skipping duplicate processing');
                return;
            }
            
            // Mark this message as processed to prevent duplicate
            this[messageProcessedKey] = true;
            
            // Check if this message is already in the messages array to avoid duplicates
            const messageExists = this.messages.some(m => m.id === msg.id);
            if (messageExists) {
                console.log('‚ö†Ô∏è Message already exists in chat, skipping duplicate');
                return;
            }
            
            // If this is a message from staff (current user), check if we have an optimistic message to replace
            if (msg.senderId === this.staffId) {
                const optimisticIndex = this.messages.findIndex(m => m.isOptimistic && m.content === msg.content);
                if (optimisticIndex !== -1) {
                    console.log('üîÑ Replacing optimistic message with real message');
                    this.messages[optimisticIndex] = msg;
                    this.$nextTick(() => this.scrollToBottom());
                    
                    // CRITICAL: Update selectedConversation status when staff sends message
                    // This ensures AI button appears immediately without page reload
                    if (this.selectedConversation && this.selectedConversation.id == msg.conversationId) {
                        console.log('üîÑ Updating selectedConversation status to ASSIGNED after staff message');
                        this.selectedConversation.status = 'ASSIGNED';
                        this.selectedConversation.assignedStaffId = this.staffId;
                        console.log('‚úÖ Updated selectedConversation:', this.selectedConversation);
                    }
                    return;
                }
            }
            
            // Determine if staff is viewing this conversation
            const isViewingConversation = this.selectedConversation && msg.conversationId == this.selectedConversation.id;
            console.log('Is viewing conversation:', isViewingConversation);
            
            // Update conversation list BEFORE adding message to chat
            // This ensures unread count is updated correctly
            this.updateConversationInList(msg.conversationId, msg, isViewingConversation);
            
            // If staff is currently viewing this conversation, add message to chat
            if (isViewingConversation) {
                console.log('‚úÖ Staff is viewing this conversation, adding message to chat');
                this.messages.push(msg);
                this.$nextTick(() => this.scrollToBottom());
                
                // If this is a system message or AI message, reload conversation data to update UI
                if (msg.isAiGenerated || msg.senderName === 'H·ªá th·ªëng') {
                    console.log('üîÑ System/AI message detected, reloading conversation data...');
                    this.reloadCurrentConversation();
                }
                
                // If message is from customer, mark as read immediately (staff is viewing)
                if (msg.senderId != this.staffId) {
                    console.log('Message from customer, marking as read immediately');
                    // Mark as read immediately since staff is viewing
                    this.markAsRead(this.selectedConversation.id);
                }
            } else {
                console.log('‚ùå Staff is NOT viewing this conversation');
                // Staff is not viewing this conversation, show notification
                if (msg.senderId != this.staffId) {
                    console.log('Showing notification for new message');
                    this.showNotification(`Tin nh·∫Øn m·ªõi t·ª´ ${msg.senderName || 'Kh√°ch h√†ng'}`);
                }
            }
        },
        
        async markAsRead(conversationId) {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                // Add JWT token from cookie for authentication
                const authToken = this.getCookie('authToken');
                if (authToken) {
                    headers['Authorization'] = 'Bearer ' + authToken;
                }
                
                await fetch(`/api/chat/conversations/${conversationId}/read`, {
                    method: 'PUT',
                    headers: headers
                });
                
                // Update unread count immediately in UI
                this.updateUnreadCountAfterMarkAsRead(conversationId);
                
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        },
        
        getCsrfToken() {
            const token = document.querySelector('meta[name="_csrf"]');
            const header = document.querySelector('meta[name="_csrf_header"]');
            return {
                token: token ? token.getAttribute('content') : null,
                header: header ? header.getAttribute('content') : null
            };
        },
        
        getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        },
        
        async sendMessageViaRest(messageDTO) {
            const csrf = this.getCsrfToken();
            const headers = {
                'Content-Type': 'application/json'
            };
            if (csrf.token) {
                headers[csrf.header] = csrf.token;
            }
            
            const response = await fetch('/api/chat/messages', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(messageDTO)
            });
            const data = await response.json();
            if (data.data && !data.error) {
                return data.data; // Return the message data
            } else {
                console.error('Error sending message:', data.error);
                throw new Error(data.error || 'Failed to send message');
            }
        },
        
        async closeConversation() {
            if (typeof confirmAction === 'function') {
                const confirmed = await confirmAction('ƒê√≥ng cu·ªôc h·ªôi tho·∫°i?', 'B·∫°n c√≥ ch·∫Øc mu·ªën ƒë√≥ng cu·ªôc h·ªôi tho·∫°i n√†y?');
                if (!confirmed) return;
            } else if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒë√≥ng cu·ªôc h·ªôi tho·∫°i n√†y?')) {
                return;
            }
            
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${this.selectedConversation.id}/close`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.selectedConversation.status = 'CLOSED';
                    // Update conversation in list without reload
                    this.updateConversationStatus(this.selectedConversation.id, 'CLOSED');
                    if (typeof showSuccess === 'function') {
                        showSuccess('ƒê√£ ƒë√≥ng cu·ªôc h·ªôi tho·∫°i');
                    }
                } else {
                    console.error('Error closing conversation:', data.error);
                    if (typeof showError === 'function') {
                        showError('Kh√¥ng th·ªÉ ƒë√≥ng cu·ªôc h·ªôi tho·∫°i: ' + data.error);
                    }
                }
            } catch (error) {
                console.error('Error closing conversation:', error);
            }
        },
        
        async reopenConversation() {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${this.selectedConversation.id}/reopen`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.selectedConversation.status = 'ASSIGNED';
                    // Update conversation in list without reload
                    this.updateConversationStatus(this.selectedConversation.id, 'ASSIGNED');
                } else {
                    console.error('Error reopening conversation:', data.error);
                }
            } catch (error) {
                console.error('Error reopening conversation:', error);
            }
        },
        
        async returnToAi() {
            console.log('ü§ñ returnToAi() called');
            console.log('ü§ñ selectedConversation:', this.selectedConversation);
            
            // PREVENT DUPLICATE CALLS
            if (this.returningToAi) {
                console.log('ü§ñ Already processing AI return, ignoring duplicate call');
                return;
            }
            
            if (!this.selectedConversation) {
                console.error('‚ùå No conversation selected');
                if (typeof showWarning === 'function') {
                    showWarning('Ch∆∞a ch·ªçn cu·ªôc h·ªôi tho·∫°i');
                }
                return;
            }
            
            // Set flag to prevent duplicate calls
            this.returningToAi = true;
            
            let confirmed = false;
            if (typeof confirmAction === 'function') {
                confirmed = await confirmAction('Trao l·∫°i cho AI?', 'Trao l·∫°i cu·ªôc h·ªôi tho·∫°i n√†y cho Hoa AI?\n\nSau 30 gi√¢y, n·∫øu kh√°ch kh√¥ng nh·∫Øn tin th√¨ AI s·∫Ω ti·∫øp t·ª•c h·ªó tr·ª£. N·∫øu kh√°ch nh·∫Øn tin trong 30 gi√¢y, b·∫°n s·∫Ω ti·∫øp t·ª•c x·ª≠ l√Ω.');
            } else {
                confirmed = confirm('Trao l·∫°i cu·ªôc h·ªôi tho·∫°i n√†y cho Hoa AI?\n\nSau 30 gi√¢y, n·∫øu kh√°ch kh√¥ng nh·∫Øn tin th√¨ AI s·∫Ω ti·∫øp t·ª•c h·ªó tr·ª£. N·∫øu kh√°ch nh·∫Øn tin trong 30 gi√¢y, b·∫°n s·∫Ω ti·∫øp t·ª•c x·ª≠ l√Ω.');
            }
            
            if (!confirmed) {
                console.log('ü§ñ User cancelled AI return');
                this.returningToAi = false; // Reset flag
                return;
            }
            
            console.log('ü§ñ Starting AI return process...');
            
            try {
                const csrf = this.getCsrfToken();
                console.log('ü§ñ CSRF token:', csrf);
                
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const url = `/api/staff/conversations/${this.selectedConversation.id}/return-to-ai`;
                console.log('ü§ñ API URL:', url);
                console.log('ü§ñ Headers:', headers);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers
                });
                
                console.log('ü§ñ Response status:', response.status);
                console.log('ü§ñ Response ok:', response.ok);
                
                const data = await response.json();
                console.log('ü§ñ Response data:', data);
                
                if (response.ok && (data.data || data.message)) {
                    this.showNotification('‚úÖ S·∫Ω trao l·∫°i cho Hoa AI sau 30 gi√¢y n·∫øu kh√°ch kh√¥ng nh·∫Øn tin');
                    console.log('‚úÖ Queued conversation for AI return');
                } else {
                    console.error('‚ùå Error returning to AI:', data.error || data.message);
                    if (typeof showError === 'function') {
                        showError('Kh√¥ng th·ªÉ trao l·∫°i cho AI: ' + (data.error || data.message || 'Unknown error'));
                    }
                }
            } catch (error) {
                console.error('‚ùå Exception in returnToAi:', error);
                if (typeof showError === 'function') {
                    showError('L·ªói khi trao l·∫°i cho AI: ' + error.message);
                }
            } finally {
                // ALWAYS reset flag to allow future calls
                this.returningToAi = false;
                console.log('ü§ñ Reset returningToAi flag');
            }
        },
        
        async searchConversations() {
            if (!this.searchQuery.trim()) {
                // Don't reload if we already have conversations loaded
                if (this.conversations.length === 0) {
                    await this.loadConversations();
                }
                return;
            }
            
            try {
                const csrf = this.getCsrfToken();
                const headers = {};
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/search?q=${encodeURIComponent(this.searchQuery)}`, {
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    this.conversations = data.data || [];
                } else {
                    console.error('Error searching conversations:', data.error);
                }
            } catch (error) {
                console.error('Error searching conversations:', error);
            }
        },
        
        async assignConversation(conversationId) {
            try {
                const csrf = this.getCsrfToken();
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (csrf.token) {
                    headers[csrf.header] = csrf.token;
                }
                
                const response = await fetch(`/api/staff/conversations/${conversationId}/assign`, {
                    method: 'POST',
                    headers: headers
                });
                const data = await response.json();
                if (data.data && !data.error) {
                    // Update conversation status without reload
                    this.updateConversationStatus(conversationId, 'ASSIGNED');
                    if (typeof showSuccess === 'function') {
                        showSuccess('ƒê√£ nh·∫≠n cu·ªôc h·ªôi tho·∫°i');
                    }
                } else {
                    console.error('Error assigning conversation:', data.error);
                    if (typeof showError === 'function') {
                        showError('Kh√¥ng th·ªÉ nh·∫≠n cu·ªôc h·ªôi tho·∫°i: ' + data.error);
                    }
                }
            } catch (error) {
                console.error('Error assigning conversation:', error);
                if (typeof showError === 'function') {
                    showError('Kh√¥ng th·ªÉ nh·∫≠n cu·ªôc h·ªôi tho·∫°i');
                }
            }
        },
        
        handleTyping() {
            if (this.typingTimeout) {
                clearTimeout(this.typingTimeout);
            }
            
            // Validate required data before sending
            if (!this.stompClient || !this.stompClient.connected || !this.selectedConversation || !this.staffId) {
                console.warn('Cannot send typing indicator: missing required data', {
                    connected: this.stompClient?.connected,
                    selectedConversation: !!this.selectedConversation,
                    staffId: this.staffId
                });
                return;
            }
            
            try {
                const typingData = {
                    conversationId: this.selectedConversation.id.toString(),
                    userId: this.staffId.toString(), // Ensure it's a string
                    userName: 'Staff'
                };
                
                console.debug('Sending typing indicator:', typingData);
                
                this.stompClient.send('/app/chat.typing', {}, JSON.stringify(typingData));
            } catch (error) {
                console.error('Error sending typing indicator:', error);
            }
            
            this.typingTimeout = setTimeout(() => {
                // Typing stopped
            }, 1000);
        },
        
        connectWebSocket() {
            try {
                const socket = new SockJS('/ws');
                this.stompClient = Stomp.over(socket);
                this.stompClient.debug = null;
                
                this.stompClient.connect({}, (frame) => {
                    console.log('WebSocket connected for chat');
                    
                    // Subscribe to handoff queue updates to refresh conversations list
                    try {
                        this.stompClient.subscribe('/topic/handoff-queue', (message) => {
                            try {
                                const notification = JSON.parse(message.body);
                                console.log('üì• Handoff queue update:', notification);
                            } catch (e) { /* noop */ }
                            // Always refresh conversations so staff sees new handoff immediately
                            this.loadConversations();
                            // Optionally also refresh any handoff-specific list if present
                            if (typeof this.loadHandoffQueue === 'function') {
                                this.loadHandoffQueue();
                            }
                            if (typeof this.showNotification === 'function') {
                                this.showNotification('C√≥ cu·ªôc h·ªôi tho·∫°i m·ªõi c·∫ßn h·ªó tr·ª£');
                            }
                        });
                    } catch (e) {
                        console.error('Error subscribing to handoff-queue:', e);
                    }

                    // Subscribe to new conversation notifications
                    this.stompClient.subscribe('/topic/notifications', (message) => {
                        const notification = JSON.parse(message.body);
                        if (notification.type === 'new_conversation') {
                            // Only reload if we don't have conversations loaded yet
                            if (this.conversations.length === 0) {
                                this.loadConversations();
                            }
                            this.showNotification(notification.message);
                        }
                    });
                    
                    // Subscribe to conversation updates (like Messenger/Zalo)
                    this.stompClient.subscribe('/topic/conversation-updates', (message) => {
                        const update = JSON.parse(message.body);
                        this.handleConversationUpdate(update);
                    });
                    
                    // Subscribe to general chat updates
                    this.stompClient.subscribe('/topic/chat-updates', (message) => {
                        const update = JSON.parse(message.body);
                        this.handleChatUpdate(update);
                    });
                    
                    // Subscribe to all chat messages for staff
                    this.stompClient.subscribe('/topic/chat/staff', (message) => {
                        const msg = JSON.parse(message.body);
                        console.log('Received message for staff:', msg);
                        this.handleIncomingMessage(msg);
                    });
                    
                }, (error) => {
                    console.error('WebSocket error:', error);
                    // Exponential backoff for reconnection
                    setTimeout(() => this.connectWebSocket(), 5000);
                });
            } catch (error) {
                console.error('Error creating WebSocket connection:', error);
            }
        },
        
        setupRealTimeUpdates() {
            // Setup periodic health check for WebSocket connection
            setInterval(() => {
                if (!this.stompClient || !this.stompClient.connected) {
                    console.log('WebSocket disconnected, attempting to reconnect...');
                    this.connectWebSocket();
                }
            }, 10000); // Check every 10 seconds
            
            // Setup periodic conversation list refresh (much less frequent)
            setInterval(() => {
                // Only refresh if no conversation is selected and no recent activity
                if (!this.selectedConversation) {
                    this.loadConversations();
                }
            }, 300000); // Refresh every 5 minutes only when no conversation selected
        },
        
        setupProcessedMessagesCleanup() {
            // Cleanup processed message flags every 5 minutes to prevent memory leak
            setInterval(() => {
                const keys = Object.keys(this).filter(key => key.startsWith('processed_'));
                if (keys.length > 100) { // Only cleanup if we have many processed messages
                    keys.forEach(key => {
                        delete this[key];
                    });
                    console.log(`üßπ Cleaned up ${keys.length} processed message flags`);
                }
            }, 300000); // Cleanup every 5 minutes
        },
        
        handleConversationUpdate(update) {
            // Update conversation in the list without full reload (like Messenger/Zalo)
            console.log('üîÑ handleConversationUpdate called:', update);
            console.log('üîÑ Update type:', update.updateType);
            console.log('üîÑ Update data:', update.data);
            
            const index = this.conversations.findIndex(c => c.id === update.conversationId);
            if (index !== -1) {
                console.log('üîÑ Found conversation at index:', index);
                console.log('üîÑ Current conversation ID:', this.conversations[index].id);
                
                // ‚ö†Ô∏è IMPORTANT: Do NOT spread update.data directly!
                // update.data might be a ChatMessageDTO with its own 'id' field (message ID)
                // which would overwrite the conversation ID!
                
                // Instead, only update specific fields we know are safe
                if (update.updateType === 'new_message' && update.data) {
                    // Update last message info from ChatMessageDTO
                    this.conversations[index].lastMessageContent = update.data.content;
                    this.conversations[index].lastMessageSenderId = update.data.senderId;
                    this.conversations[index].lastMessageAt = update.data.sentAt;
                    
                    console.log('üîÑ Updated last message info');
                    console.log('üîÑ Conversation ID after update:', this.conversations[index].id);
                    
                    // Move updated conversation to top (like Messenger/Zalo)
                    if (index > 0) {
                        const updatedConv = this.conversations.splice(index, 1)[0];
                        this.conversations.unshift(updatedConv);
                        console.log('üîÑ Moved conversation to top');
                    }
                } else {
                    // For other update types, safely update only known conversation fields
                    if (update.data.status) {
                        this.conversations[index].status = update.data.status;
                    }
                    if (update.data.priority) {
                        this.conversations[index].priority = update.data.priority;
                    }
                    console.log('üîÑ Updated conversation status/priority');
                }
                
                console.log('üîÑ Final conversation ID:', this.conversations[index].id);
            } else if (update.updateType === 'new_conversation') {
                console.log('üîÑ New conversation, checking if exists...');
                // Only reload conversations if it's truly a new conversation
                // Don't reload if it's just an update to existing conversation
                // Check if conversation already exists in our list
                const exists = this.conversations.some(c => c.id === update.conversationId);
                if (!exists) {
                    console.log('üîÑ Conversation does not exist, loading conversations...');
                    this.loadConversations();
                } else {
                    console.log('üîÑ Conversation already exists, skipping reload');
                }
            }
        },
        
        handleChatUpdate(update) {
            // Handle general chat updates (like Messenger/Zalo)
            console.log('üì¢ handleChatUpdate called:', update);
            switch (update.type) {
                case 'message_sent':
                    // ‚ö†Ô∏è REMOVED: Don't call updateConversationInList here!
                    // This causes duplicate processing because the same message is already processed
                    // in handleIncomingMessage from /topic/chat/staff subscription
                    console.log('üì¢ Message sent update received, but skipping to avoid duplicate processing');
                    console.log('üì¢ Message is already processed in handleIncomingMessage');
                    break;
                case 'conversation_status_changed':
                    // Update conversation status
                    this.handleConversationUpdate(update);
                    break;
                case 'user_typing':
                    // Handle typing indicators
                    this.handleTypingIndicator(update);
                    break;
                default:
                    console.log('Unknown chat update type:', update.type);
            }
        },
        
        handleTypingIndicator(update) {
            // Show typing indicator (like Messenger/Zalo)
            if (this.selectedConversation && update.conversationId === this.selectedConversation.id) {
                this.isTyping = true;
                setTimeout(() => {
                    this.isTyping = false;
                }, 3000);
            }
        },
        
        updateConversationInList(conversationId, messageData, isViewingConversation = false) {
            console.log('üìù updateConversationInList called:', { 
                conversationId, 
                messageData, 
                staffId: this.staffId,
                isViewingConversation 
            });
            
            // Update specific conversation without reloading entire list
            const index = this.conversations.findIndex(c => c.id == conversationId);
            console.log('üìù Found conversation at index:', index);
            
            if (index !== -1) {
                console.log('üìù Current conversation ID:', this.conversations[index].id);
                console.log('üìù Current unread count:', this.conversations[index].unreadCount);
                
                // ‚ö†Ô∏è IMPORTANT: Preserve conversation ID!
                const originalConvId = this.conversations[index].id;
                
                // Update last message info
                this.conversations[index].lastMessageContent = messageData.content;
                this.conversations[index].lastMessageSenderId = messageData.senderId;
                this.conversations[index].lastMessageAt = messageData.sentAt;
                
                console.log('üìù Message from:', messageData.senderId, 'Staff ID:', this.staffId);
                console.log('üìù Is from customer:', messageData.senderId != this.staffId);
                console.log('üìù Is viewing conversation:', isViewingConversation);
                
                // Update unread count logic:
                // - If message is from customer AND staff is NOT viewing: increase unread count
                // - If message is from customer AND staff IS viewing: don't increase (will be marked as read)
                // - If message is from staff: reset to 0
                if (messageData.senderId != this.staffId) {
                    // Message from customer
                    if (!isViewingConversation) {
                        // Staff is NOT viewing this conversation - increase unread count
                        const oldCount = this.conversations[index].unreadCount || 0;
                        this.conversations[index].unreadCount = oldCount + 1;
                        console.log(`‚úÖ Increased unread count for conversation ${conversationId}: ${oldCount} -> ${this.conversations[index].unreadCount}`);
                        
                        // Alpine.js automatically updates UI (reactive)
                    } else {
                        // Staff IS viewing this conversation - don't increase, will be marked as read
                        console.log(`üìù Staff is viewing conversation ${conversationId}, not increasing unread count (will be marked as read)`);
                    }
                } else {
                    // Message from staff - reset unread count to 0 (staff just replied)
                    console.log(`üìù Message from staff, resetting unread count to 0`);
                    this.conversations[index].unreadCount = 0;
                    // Alpine.js automatically updates UI (reactive)
                }
                
                // ‚ö†Ô∏è CRITICAL: Ensure conversation ID is preserved after updates
                this.conversations[index].id = originalConvId;
                console.log('üìù Preserved conversation ID:', this.conversations[index].id);
                console.log('üìù Final unread count:', this.conversations[index].unreadCount);
                
                // Move conversation to top if it has a new message
                if (index > 0) {
                    const updatedConv = this.conversations.splice(index, 1)[0];
                    // Double-check ID is preserved
                    updatedConv.id = originalConvId;
                    this.conversations.unshift(updatedConv);
                    console.log('‚úÖ Moved conversation to top with ID:', updatedConv.id);
                }
            } else {
                console.log('‚ùå Conversation not found in list:', conversationId);
            }
        },
        
        updateConversationStatus(conversationId, newStatus) {
            // Update conversation status without reloading entire list
            const index = this.conversations.findIndex(c => c.id === conversationId);
            if (index !== -1) {
                this.conversations[index].status = newStatus;
                
                // Update selected conversation if it's the same
                if (this.selectedConversation && this.selectedConversation.id === conversationId) {
                    this.selectedConversation.status = newStatus;
                }
            }
        },
        
        updateUnreadCountAfterStaffMessage() {
            // When staff sends a message, reset unread count for this conversation
            if (this.selectedConversation) {
                const index = this.conversations.findIndex(c => c.id === this.selectedConversation.id);
                if (index !== -1) {
                    // Reset unread count to 0 since staff just replied
                    this.conversations[index].unreadCount = 0;
                }
            }
        },
        
        updateUnreadCountAfterMarkAsRead(conversationId) {
            // When staff marks conversation as read, reset unread count
            const index = this.conversations.findIndex(c => c.id == conversationId);
            if (index !== -1) {
                // Reset unread count to 0 since staff marked as read
                const oldCount = this.conversations[index].unreadCount;
                this.conversations[index].unreadCount = 0;
                console.log(`‚úÖ Reset unread count for conversation ${conversationId}: ${oldCount} -> 0`);
                // Alpine.js automatically updates UI (reactive)
            } else {
                console.log(`‚ùå Conversation ${conversationId} not found when trying to reset unread count`);
            }
        },
        
        forceUpdateUI() {
            // Alpine.js automatically updates UI - this method is no longer needed
            console.log('üîÑ UI auto-updates (Alpine reactive)');
        },
        
        // Debug method to test conversation selection
        debugSelectConversation(convId) {
            console.log('üîç Debug: Testing conversation selection for ID:', convId);
            const conv = this.conversations.find(c => c.id == convId);
            if (conv) {
                console.log('üîç Found conversation:', conv);
                this.selectConversation(conv);
            } else {
                console.log('üîç Conversation not found in list');
                console.log('üîç Available conversations:', this.conversations.map(c => ({ id: c.id, name: c.customerName })));
            }
        },
        
        // Global method to select conversation by ID (called from notifications)
        selectConversationById(conversationId) {
            console.log('üîî Selecting conversation from notification:', conversationId);
            
            // Find conversation in list
            const conv = this.conversations.find(c => c.id == conversationId);
            
            if (conv) {
                // Select the conversation
                this.selectConversation(conv);
                
                // Scroll to top of conversation list to show selected
                const convList = document.querySelector('.chat-scrollbar');
                if (convList) {
                    convList.scrollTop = 0;
                }
            } else {
                // Conversation not in list yet, load it
                console.log('üîî Conversation not in list, loading conversations...');
                this.loadConversations().then(() => {
                    const foundConv = this.conversations.find(c => c.id == conversationId);
                    if (foundConv) {
                        this.selectConversation(foundConv);
                    } else {
                        console.error('‚ùå Conversation still not found after reload:', conversationId);
                        // Show error to user
                        if (typeof showError === 'function') {
                            showError('Kh√¥ng t√¨m th·∫•y cu·ªôc h·ªôi tho·∫°i n√†y');
                        }
                    }
                });
            }
        },
        
        showNotification(message) {
            // Create notification element with better styling
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center space-x-2 animate-pulse';
            notification.innerHTML = `
                <i class="fas fa-bell"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notification);
            
            // Add sound notification (optional)
            try {
                const audio = new Audio('/sounds/notification.mp3');
                audio.play().catch(() => {
                    // Ignore if audio file doesn't exist
                });
            } catch (e) {
                // Ignore audio errors
            }
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 5000);
        },
        
        scrollToBottom() {
            this.$nextTick(() => {
                const container = document.getElementById('messagesContainer');
                if (container) {
                    // Force scroll to bottom immediately
                    container.scrollTop = container.scrollHeight;
                    
                    // Also try smooth scroll as backup
                    setTimeout(() => {
                        container.scrollTo({
                            top: container.scrollHeight,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
            });
        },
        
        handleScroll(event) {
            // Load more messages if scrolled to top
            if (event.target.scrollTop === 0 && !this.loadingMessages) {
                // TODO: Load more messages
            }
        },
        
        formatTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'V·ª´a xong';
            if (diff < 3600000) return Math.floor(diff / 60000) + ' ph√∫t';
            if (diff < 86400000) return Math.floor(diff / 3600000) + ' gi·ªù';
            return date.toLocaleDateString('vi-VN');
        },
        
        formatMessageTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            return date.toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'});
        },
        
        formatDateTime(dateTime) {
            if (!dateTime) return '';
            const date = new Date(dateTime);
            return date.toLocaleString('vi-VN');
        },
        
        parseMarkdown(text) {
            if (!text) return '';
            
            let html = text;
            
            // Fix escaped newlines from JSON (\\n -> actual newline)
            html = html.replace(/\\n/g, '\n');
            
            // Parse images first: ![alt](url) - using safer regex construction
            const imageRegex = new RegExp('!\\[([^\\]]*)\\]\\(([^)]+)\\)', 'g');
            html = html.replace(imageRegex, function(match, alt, url) {
                const safeAlt = alt.replace(/"/g, '&quot;');
                return '<img src="' + url + '" alt="' + safeAlt + '" class="max-w-full h-auto rounded-lg my-2 cursor-pointer message-image-hover" style="max-width: 200px;" onclick="window.open(\'' + url + '\', \'_blank\')" />';
            });
            
            // Parse links: [text](url) - using safer regex construction
            const linkRegex = new RegExp('\\[([^\\]]+)\\]\\(([^)]+)\\)', 'g');
            html = html.replace(linkRegex, function(match, text, url) {
                return '<a href="' + url + '" target="_blank" class="text-blue-600 hover:underline">' + text + '</a>';
            });
            
            // Parse bold: **text**
            const boldRegex = new RegExp('\\*\\*([^*]+)\\*\\*', 'g');
            html = html.replace(boldRegex, '<strong>$1</strong>');
            
            // Parse bullet lists: * item or - item
            const listRegex = new RegExp('^[\\*\\-]\\s+(.+)$', 'gm');
            html = html.replace(listRegex, '<li class="ml-4 mb-1">‚Ä¢ $1</li>');
            
            // Wrap consecutive list items in ul
            const ulRegex = new RegExp('(<li[^>]*>.*?<\\/li>\\s*)+', 'g');
            html = html.replace(ulRegex, function(match) {
                return '<ul class="my-2 space-y-1">' + match + '</ul>';
            });
            
            // Parse numbered list items: 1Ô∏è‚É£, 2Ô∏è‚É£, etc.
            const emojiRegex = new RegExp('(\\d)Ô∏è‚É£', 'g');
            html = html.replace(emojiRegex, '<span class="font-bold text-pink-600">$1Ô∏è‚É£</span>');
            
            // Parse line breaks (but not inside lists)
            const brRegex = new RegExp('\\n(?![<ul>|<li>])', 'g');
            html = html.replace(brRegex, '<br>');
            
            // Clean up extra br tags around lists and images
            html = html.replace(/<br>\s*<ul>/g, '<ul>');
            html = html.replace(/<\/ul>\s*<br>/g, '</ul>');
            html = html.replace(/<br>\s*<img/g, '<img');
            html = html.replace(/\/>\s*<br>/g, '/>');
            
            return html;
        },
        
        getStatusText(status) {
            const map = {
                'OPEN': 'Ch∆∞a x·ª≠ l√Ω',
                'ASSIGNED': 'ƒêang x·ª≠ l√Ω',
                'CLOSED': 'ƒê√£ ƒë√≥ng'
            };
            return map[status] || status;
        },
        
        getPriorityText(priority) {
            const map = {
                'LOW': 'Th·∫•p',
                'NORMAL': 'B√¨nh th∆∞·ªùng',
                'HIGH': 'Cao',
                'URGENT': 'Kh·∫©n c·∫•p'
            };
            return map[priority] || priority;
        },
        
        // Helper functions for optimistic messages
        replaceOptimisticMessage(optimisticId, realMessage) {
            const index = this.messages.findIndex(m => m.id === optimisticId);
            if (index !== -1) {
                this.messages[index] = realMessage;
                console.log('‚úÖ Replaced optimistic message with real message');
            }
        },
        
        removeOptimisticMessage(optimisticId) {
            const index = this.messages.findIndex(m => m.id === optimisticId);
            if (index !== -1) {
                this.messages.splice(index, 1);
                console.log('‚ùå Removed failed optimistic message');
            }
        }
    }
}

</script>
