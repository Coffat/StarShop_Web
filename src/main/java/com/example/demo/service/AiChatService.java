package com.example.demo.service;

import com.example.demo.client.GeminiClient;
import com.example.demo.dto.AiAnalysisResult;
import com.example.demo.entity.Conversation;
import com.example.demo.entity.Message;
import com.example.demo.entity.RoutingDecision;
import com.example.demo.entity.enums.HandoffReason;
import com.example.demo.entity.enums.IntentType;
import com.example.demo.repository.ConversationRepository;
import com.example.demo.repository.MessageRepository;
import com.example.demo.repository.RoutingDecisionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Service for AI chat functionality
 * Handles message analysis, response generation, and tool execution
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AiChatService {

    private final GeminiClient geminiClient;
    private final AiPromptService promptService;
    private final StoreConfigService storeConfigService;
    private final PiiDetectionService piiDetectionService;
    private final RoutingDecisionRepository routingDecisionRepository;
    private final ConversationRepository conversationRepository;
    private final MessageRepository messageRepository;
    private final WebSocketService webSocketService;

    /**
     * Analyze customer message using AI
     */
    @Transactional
    public AiAnalysisResult analyzeMessage(Long conversationId, String customerMessage) {
        long startTime = System.currentTimeMillis();
        
        try {
            log.info("Analyzing message for conversation {}", conversationId);
            
            // Check for PII first
            if (piiDetectionService.containsPII(customerMessage)) {
                log.warn("‚ö†Ô∏è PII DETECTED in conversation {}: {}", conversationId, 
                    piiDetectionService.getPIITypes(customerMessage));
                
                // Send urgent notification to ALL staff
                try {
                    Conversation conversation = conversationRepository.findById(conversationId).orElse(null);
                    if (conversation != null && conversation.getCustomer() != null) {
                        String customerName = conversation.getCustomer().getFullName();
                        String piiTypes = piiDetectionService.getPIITypes(customerMessage);
                        
                        // Send broadcast notification to all staff
                        webSocketService.sendBroadcast(
                            String.format("üö® PH√ÅT HI·ªÜN TH√îNG TIN C√Å NH√ÇN t·ª´ kh√°ch h√†ng %s (Lo·∫°i: %s)", 
                                customerName, piiTypes),
                            "pii_alert"
                        );
                        
                        log.info("PII alert sent to all staff for conversation {}", conversationId);
                    }
                } catch (Exception e) {
                    log.error("Error sending PII notification", e);
                }
                
                return createHandoffResult(IntentType.OTHER, 0.5, 
                    "M√¨nh xin ph√©p chuy·ªÉn b·∫°n cho nh√¢n vi√™n ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin c√° nh√¢n nh√© üí¨",
                    HandoffReason.PII_DETECTED);
            }

            // Get conversation history
            String conversationHistory = getConversationHistory(conversationId);
            
            // Generate prompts
            String systemPrompt = promptService.generateSystemPrompt();
            String userMessage = promptService.generateUserMessage(customerMessage, conversationHistory);
            
            // Call Gemini API
            AiAnalysisResult result = geminiClient.analyzeMessage(systemPrompt, userMessage);
            
            if (result == null) {
                log.error("Failed to get AI analysis, forcing handoff");
                return createHandoffResult(IntentType.OTHER, 0.0,
                    "Xin l·ªói b·∫°n, m√¨nh ƒëang g·∫∑p ch√∫t v·∫•n ƒë·ªÅ k·ªπ thu·∫≠t. ƒê·ªÉ m√¨nh chuy·ªÉn cho nh√¢n vi√™n h·ªó tr·ª£ b·∫°n nh√© üí¨",
                    HandoffReason.AI_ERROR);
            }

            // Calculate processing time
            long processingTime = System.currentTimeMillis() - startTime;
            
            // Save routing decision
            saveRoutingDecision(conversationId, result, processingTime);
            
            log.info("AI analysis completed - Intent: {}, Confidence: {}, Handoff: {}", 
                result.getIntent(), result.getConfidence(), result.getNeedHandoff());
            
            return result;
            
        } catch (Exception e) {
            log.error("Error analyzing message", e);
            return createHandoffResult(IntentType.OTHER, 0.0,
                "Xin l·ªói b·∫°n, h·ªá th·ªëng ƒëang b·∫≠n. ƒê·ªÉ m√¨nh chuy·ªÉn cho nh√¢n vi√™n h·ªó tr·ª£ b·∫°n nh√© üí¨",
                HandoffReason.AI_ERROR);
        }
    }
    
    /**
     * Generate final AI response after tool execution
     * This creates a context-aware, detailed response based on actual product data
     */
    public String generateFinalResponse(Long conversationId, String customerMessage, 
                                       String toolResults, AiAnalysisResult initialAnalysis) {
        try {
            log.info("Generating final AI response with tool results for conversation {}", conversationId);
            
            // Get conversation history
            String conversationHistory = getConversationHistory(conversationId);
            
            // Build enhanced prompt for final response
            StringBuilder finalPrompt = new StringBuilder();
            finalPrompt.append("B·∫†N L√Ä: Hoa AI - chuy√™n vi√™n t∆∞ v·∫•n hoa chuy√™n nghi·ªáp\n\n");
            
            finalPrompt.append("L·ªäCH S·ª¨ H·ªòI THO·∫†I:\n");
            if (conversationHistory != null && !conversationHistory.isEmpty()) {
                finalPrompt.append(conversationHistory).append("\n\n");
            }
            
            finalPrompt.append("KH√ÅCH H√ÄNG V·ª™A H·ªéI: ").append(customerMessage).append("\n\n");
            
            finalPrompt.append("K·∫æT QU·∫¢ T√åM KI·∫æM S·∫¢N PH·∫®M:\n");
            finalPrompt.append(toolResults).append("\n\n");
            
            finalPrompt.append("NHI·ªÜM V·ª§:\n");
            finalPrompt.append("1. Ph√¢n t√≠ch K·ª∏ m·ª•c ƒë√≠ch/ng·ªØ c·∫£nh c·ªßa kh√°ch (v√≠ d·ª•: t·∫∑ng m·∫π, t·∫∑ng ng∆∞·ªùi y√™u, sinh nh·∫≠t...)\n");
            finalPrompt.append("2. D·ª±a tr√™n danh s√°ch s·∫£n ph·∫©m T√åM TH·∫§Y, t∆∞ v·∫•n 2-3 s·∫£n ph·∫©m PH√ô H·ª¢P NH·∫§T\n");
            finalPrompt.append("3. Gi·∫£i th√≠ch NG·∫ÆN G·ªåN nh∆∞ng ·∫§M √ÅP t·∫°i sao s·∫£n ph·∫©m ph√π h·ª£p\n");
            finalPrompt.append("4. Hi·ªÉn th·ªã ·∫£nh: ![T√™n](url) v√† gi√°\n");
            finalPrompt.append("5. D√πng emoji ph√π h·ª£p (üíï üå∏ ‚ú®) ƒë·ªÉ th√¢n thi·ªán\n\n");
            
            finalPrompt.append("QUY T·∫ÆC T∆Ø V·∫§N:\n");
            finalPrompt.append("- N·∫øu s·∫£n ph·∫©m KH·ªöP ƒë√∫ng y√™u c·∫ßu ‚Üí t∆∞ v·∫•n nhi·ªát t√¨nh\n");
            finalPrompt.append("- N·∫øu s·∫£n ph·∫©m T∆Ø∆†NG T·ª∞ (hoa kh√°c nh∆∞ng ph√π h·ª£p m·ª•c ƒë√≠ch) ‚Üí gi·∫£i th√≠ch kh√©o: \"Hi·ªán shop ch∆∞a c√≥ [X], nh∆∞ng [Y] c≈©ng r·∫•t ph√π h·ª£p ƒë·ªÉ [m·ª•c ƒë√≠ch] v√¨ [l√Ω do]\"\n");
            finalPrompt.append("- N·∫øu gi√° CAO H∆†N y√™u c·∫ßu ‚Üí g·ª£i √Ω ƒëi·ªÅu ch·ªânh ho·∫∑c s·∫£n ph·∫©m r·∫ª h∆°n\n");
            finalPrompt.append("- KH√îNG bao gi·ªù n√≥i \"kh√¥ng c√≥\" r·ªìi d·ª´ng ‚Üí lu√¥n t√¨m c√°ch t∆∞ v·∫•n\n");
            finalPrompt.append("- G·ªçi kh√°ch l√† \"b·∫°n\", t·ª± x∆∞ng l√† \"m√¨nh\"\n\n");
            
            finalPrompt.append("V√ç D·ª§ T∆Ø V·∫§N T·ªêT (NG·∫ÆN G·ªåN):\n");
            finalPrompt.append("\"T·∫∑ng m·∫π th√¨ hoa h·ªìng ph·∫•n r·∫•t ph√π h·ª£p n√® b·∫°n! üíï\n\n");
            finalPrompt.append("* **B√≥ h·ªìng ph·∫•n Sweetie** - 520,000ƒë\n");
            finalPrompt.append("![B√≥ h·ªìng ph·∫•n](url)\n");
            finalPrompt.append("H·ªìng ph·∫•n t∆∞·ª£ng tr∆∞ng cho t√¨nh th∆∞∆°ng d·ªãu d√†ng - ho√†n h·∫£o ƒë·ªÉ t·∫∑ng m·∫π ·∫°!\n\n");
            finalPrompt.append("B·∫°n mu·ªën m√¨nh t∆∞ v·∫•n th√™m kh√¥ng ·∫°? üòä\"\n\n");
            
            finalPrompt.append("CH√ö √ù QUAN TR·ªåNG: \n");
            finalPrompt.append("- ‚ö†Ô∏è KH√îNG BAO GI·ªú tr·∫£ v·ªÅ JSON format (kh√¥ng c√≥ {}, [], \"key\":\"value\")\n");
            finalPrompt.append("- ‚ö†Ô∏è KH√îNG copy nguy√™n ph·∫ßn 'TOOL_RESULT' hay 'H∆Ø·ªöNG D·∫™N'\n");
            finalPrompt.append("- Ch·ªâ vi·∫øt TEXT thu·∫ßn t√∫y v·ªõi markdown (*, **, ![]())\n");
            finalPrompt.append("- Response ph·∫£i NG·∫ÆN G·ªåN (2-4 c√¢u + bullet list s·∫£n ph·∫©m)\n\n");
            
            finalPrompt.append("B·∫ÆT ƒê·∫¶U T∆Ø V·∫§N (TEXT ONLY, NO JSON):\n");
            
            // Call Gemini to generate final response
            String systemPrompt = "T∆∞ v·∫•n hoa NG·∫ÆN G·ªåN, ·∫§M √ÅP. Ch·ªâ tr·∫£ TEXT v·ªõi markdown (* list, ** bold, ![](url)). KH√îNG BAO GI·ªú tr·∫£ JSON!";
            
            com.example.demo.dto.gemini.GeminiResponse response = geminiClient.generateContentWithSystemPrompt(
                systemPrompt, 
                finalPrompt.toString()
            );
            
            if (response != null && response.isSuccessful()) {
                String finalResponse = response.getTextResponse();
                log.info("Generated final response: {} chars", finalResponse.length());
                
                // Clean up JSON wrapper if AI returned JSON format
                finalResponse = cleanJsonWrapper(finalResponse);
                
                // Clean up any TOOL_RESULT prefix if AI accidentally included it
                finalResponse = finalResponse.replaceAll("(?i)TOOL_RESULT:\\s*", "");
                finalResponse = finalResponse.replaceAll("(?i)H∆Ø·ªöNG D·∫™N:.*", "");
                
                return finalResponse.trim();
            } else {
                log.warn("Failed to generate final response, using fallback");
                // Fallback: clean tool results and show simple message
                String cleanToolResults = toolResults
                    .replaceAll("(?i)TOOL_RESULT:\\s*T√¨m th·∫•y \\d+ s·∫£n ph·∫©m:\\s*", "")
                    .replaceAll("(?i)H∆Ø·ªöNG D·∫™N:.*", "")
                    .trim();
                
                return initialAnalysis.getReply() + "\n\n" + 
                    "M√¨nh t√¨m th·∫•y m·ªôt s·ªë s·∫£n ph·∫©m cho b·∫°n n√®:\n\n" + cleanToolResults;
            }
            
        } catch (Exception e) {
            log.error("Error generating final response", e);
            // Fallback: clean tool results
            String cleanToolResults = toolResults
                .replaceAll("(?i)TOOL_RESULT:\\s*T√¨m th·∫•y \\d+ s·∫£n ph·∫©m:\\s*", "")
                .replaceAll("(?i)H∆Ø·ªöNG D·∫™N:.*", "")
                .trim();
            
            return initialAnalysis.getReply() + "\n\n" + 
                "M√¨nh t√¨m th·∫•y m·ªôt s·ªë s·∫£n ph·∫©m cho b·∫°n n√®:\n\n" + cleanToolResults;
        }
    }
    
    /**
     * Clean JSON wrapper if AI accidentally returned JSON format
     * Extract content from: {"messages":[{"content":"..."}]} or similar
     */
    private String cleanJsonWrapper(String response) {
        if (response == null || response.isEmpty()) {
            return response;
        }
        
        String cleaned = response.trim();
        
        // Check if response starts with JSON
        if (cleaned.startsWith("{") || cleaned.startsWith("[")) {
            try {
                // Try to extract content from JSON structure
                // Pattern 1: {"messages":[{"role":"assistant","content":"..."}]}
                if (cleaned.contains("\"content\"")) {
                    int contentStart = cleaned.indexOf("\"content\"");
                    if (contentStart > 0) {
                        contentStart = cleaned.indexOf(":", contentStart) + 1;
                        contentStart = cleaned.indexOf("\"", contentStart) + 1;
                        int contentEnd = cleaned.lastIndexOf("\"");
                        
                        if (contentStart > 0 && contentEnd > contentStart) {
                            String extracted = cleaned.substring(contentStart, contentEnd);
                            // Unescape JSON string
                            extracted = extracted
                                .replace("\\n", "\n")
                                .replace("\\\"", "\"")
                                .replace("\\\\", "\\")
                                .replace("\\/", "/");
                            
                            log.info("Extracted content from JSON wrapper");
                            return extracted;
                        }
                    }
                }
                
                // Pattern 2: {"reply":"..."}
                if (cleaned.contains("\"reply\"")) {
                    int replyStart = cleaned.indexOf("\"reply\"");
                    if (replyStart > 0) {
                        replyStart = cleaned.indexOf(":", replyStart) + 1;
                        replyStart = cleaned.indexOf("\"", replyStart) + 1;
                        int replyEnd = cleaned.indexOf("\"", replyStart);
                        
                        if (replyStart > 0 && replyEnd > replyStart) {
                            String extracted = cleaned.substring(replyStart, replyEnd);
                            extracted = extracted
                                .replace("\\n", "\n")
                                .replace("\\\"", "\"")
                                .replace("\\\\", "\\");
                            
                            log.info("Extracted reply from JSON");
                            return extracted;
                        }
                    }
                }
                
            } catch (Exception e) {
                log.warn("Failed to parse JSON wrapper, returning as-is", e);
            }
        }
        
        // If not JSON or failed to parse, return as-is
        return cleaned;
    }

    /**
     * Get conversation history for context
     */
    private String getConversationHistory(Long conversationId) {
        try {
            List<Message> messages = messageRepository.findByConversationIdOrderBySentAtAsc(conversationId);
            
            if (messages.isEmpty()) {
                return "";
            }

            // Get last N messages
            int maxMessages = storeConfigService.getConfigAsInt("ai.max_conversation_history", 10);
            int start = Math.max(0, messages.size() - maxMessages);
            List<Message> recentMessages = messages.subList(start, messages.size());
            
            List<String> history = new ArrayList<>();
            for (Message msg : recentMessages) {
                String sender = msg.getSender().getFullName();
                String content = msg.getContent();
                history.add(sender + ": " + content);
            }
            
            return String.join("\n", history);
            
        } catch (Exception e) {
            log.error("Error getting conversation history", e);
            return "";
        }
    }

    /**
     * Save routing decision to database
     */
    @Transactional
    public void saveRoutingDecision(Long conversationId, AiAnalysisResult result, long processingTimeMs) {
        try {
            Conversation conversation = conversationRepository.findById(conversationId)
                .orElseThrow(() -> new RuntimeException("Conversation not found"));

            RoutingDecision decision = new RoutingDecision();
            decision.setConversation(conversation);
            decision.setIntent(result.getIntentType());
            decision.setConfidence(result.getConfidenceAsBigDecimal());
            decision.setNeedHandoff(result.requiresHandoff());
            decision.setSuggestHandoff(result.suggestsHandoff());
            decision.setAiResponse(result.getReply());
            decision.setProcessingTimeMs((int) processingTimeMs);
            
            // Set handoff reason if needed
            if (result.requiresHandoff()) {
                decision.setHandoffReason(determineHandoffReason(result));
            }
            
            // Set tools used
            if (result.hasToolRequests()) {
                List<String> toolNames = new ArrayList<>();
                for (AiAnalysisResult.ToolRequest tool : result.getToolRequests()) {
                    toolNames.add(tool.getName());
                }
                decision.setToolsUsed(toolNames.toArray(new String[0]));
            }
            
            routingDecisionRepository.save(decision);
            log.debug("Routing decision saved for conversation {}", conversationId);
            
        } catch (Exception e) {
            log.error("Error saving routing decision", e);
        }
    }

    /**
     * Determine handoff reason from AI result
     */
    private HandoffReason determineHandoffReason(AiAnalysisResult result) {
        IntentType intent = result.getIntentType();
        
        if (result.getConfidence() != null && result.getConfidence() < 0.65) {
            return HandoffReason.LOW_CONFIDENCE;
        }
        
        switch (intent) {
            case ORDER_SUPPORT:
                return HandoffReason.ORDER_INQUIRY;
            case PAYMENT:
                return HandoffReason.PAYMENT_ISSUE;
            default:
                return HandoffReason.COMPLEX_QUERY;
        }
    }

    /**
     * Create handoff result when AI cannot handle
     */
    private AiAnalysisResult createHandoffResult(IntentType intent, double confidence, 
                                                  String reply, HandoffReason reason) {
        AiAnalysisResult result = new AiAnalysisResult();
        result.setIntent(intent.name());
        result.setConfidence(confidence);
        result.setReply(reply);
        result.setNeedHandoff(true);
        result.setSuggestHandoff(false);
        result.setToolRequests(new ArrayList<>());
        result.setProductSuggestions(new ArrayList<>());
        return result;
    }

    /**
     * Check if AI should handle the message based on confidence
     */
    public boolean shouldAiHandle(AiAnalysisResult result) {
        if (result == null) {
            return false;
        }

        // Check if handoff is required
        if (result.requiresHandoff()) {
            return false;
        }

        // Check confidence threshold
        Map<String, Double> thresholds = storeConfigService.getConfidenceThresholds();
        double autoThreshold = thresholds.getOrDefault("auto", 0.80);
        
        return result.isConfidentEnough(autoThreshold);
    }

    /**
     * Check if AI suggests handoff
     */
    public boolean shouldSuggestHandoff(AiAnalysisResult result) {
        if (result == null || result.requiresHandoff()) {
            return false;
        }

        Map<String, Double> thresholds = storeConfigService.getConfidenceThresholds();
        double suggestThreshold = thresholds.getOrDefault("suggest", 0.65);
        double autoThreshold = thresholds.getOrDefault("auto", 0.80);
        
        return result.getConfidence() >= suggestThreshold && 
               result.getConfidence() < autoThreshold;
    }

    /**
     * Format AI reply with handoff suggestion if needed
     */
    public String formatReplyWithHandoffSuggestion(AiAnalysisResult result) {
        String reply = result.getReply();
        
        if (shouldSuggestHandoff(result)) {
            reply += "\n\n_B·∫°n c√≥ mu·ªën m√¨nh chuy·ªÉn cho nh√¢n vi√™n ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ t·ªët h∆°n kh√¥ng?_ üí¨";
        }
        
        return reply;
    }
}

