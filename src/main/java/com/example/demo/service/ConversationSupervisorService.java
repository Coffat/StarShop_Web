package com.example.demo.service;

import com.example.demo.entity.Conversation;
import com.example.demo.entity.Message;
import com.example.demo.entity.User;
import com.example.demo.entity.enums.ConversationStatus;
import com.example.demo.entity.enums.UserRole;
import com.example.demo.repository.ConversationRepository;
import com.example.demo.repository.MessageRepository;
import com.example.demo.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Service qu·∫£n l√Ω vi·ªác trao l·∫°i conversation cho AI sau khi staff b·∫•m n√∫t "AI"
 * Ch·ªù 30 gi√¢y, n·∫øu kh√°ch kh√¥ng nh·∫Øn tin th√¨ trao l·∫°i cho AI
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ConversationSupervisorService {
    
    private final ConversationRepository conversationRepository;
    private final MessageRepository messageRepository;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final WebSocketService webSocketService;
    
    // Map l∆∞u conversation ƒëang ch·ªù trao l·∫°i cho AI: conversationId -> deadline
    private final ConcurrentMap<Long, LocalDateTime> aiResumePending = new ConcurrentHashMap<>();
    
    private static final int WAIT_SECONDS = 30;
    
    /**
     * ƒê∆∞a conversation v√†o h√†ng ƒë·ª£i trao l·∫°i cho AI
     * G·ª≠i th√¥ng b√°o cho kh√°ch v√† b·∫Øt ƒë·∫ßu ƒë·∫øm 30 gi√¢y
     */
    @Transactional
    public void queueReturnToAi(Long conversationId) {
        try {
            Conversation conversation = conversationRepository.findById(conversationId)
                .orElseThrow(() -> new RuntimeException("Conversation not found: " + conversationId));
            
            if (conversation.getAssignedStaff() == null) {
                log.warn("Cannot queue return to AI: conversation {} has no assigned staff", conversationId);
                return;
            }
            
            // ƒê∆∞a v√†o h√†ng ƒë·ª£i
            LocalDateTime deadline = LocalDateTime.now().plusSeconds(WAIT_SECONDS);
            aiResumePending.put(conversationId, deadline);
            
            log.info("ü§ñ Queued conversation {} for AI return (deadline: {})", conversationId, deadline);
            
            // G·ª≠i system message th√¥ng b√°o cho kh√°ch
            User systemUser = getOrCreateSystemUser();
            Message systemMessage = new Message();
            systemMessage.setConversationId(conversationId);
            systemMessage.setSender(systemUser);
            systemMessage.setReceiver(conversation.getCustomer());
            systemMessage.setContent(
                "N·∫øu b·∫°n kh√¥ng c√≤n th·∫Øc m·∫Øc n√†o c·∫ßn nh√¢n vi√™n h·ªó tr·ª£ tr·ª±c ti·∫øp, " +
                "sau " + WAIT_SECONDS + " gi√¢y n·ªØa Hoa AI s·∫Ω ti·∫øp t·ª•c t∆∞ v·∫•n cho b·∫°n. " +
                "N·∫øu trong " + WAIT_SECONDS + " gi√¢y n√†y b·∫°n nh·∫Øn tin, nh√¢n vi√™n s·∫Ω ti·∫øp t·ª•c h·ªó tr·ª£ b·∫°n nh√©! üí¨"
            );
            systemMessage.setIsAiGenerated(false);
            systemMessage.setSentAt(LocalDateTime.now());
            Message savedMessage = messageRepository.save(systemMessage);
            
            // G·ª≠i message qua WebSocket cho customer
            com.example.demo.dto.ChatMessageDTO messageDTO = new com.example.demo.dto.ChatMessageDTO();
            messageDTO.setId(savedMessage.getId());
            messageDTO.setConversationId(conversationId);
            messageDTO.setSenderId(systemUser.getId());
            messageDTO.setSenderName("H·ªá th·ªëng");
            messageDTO.setContent(savedMessage.getContent());
            messageDTO.setSentAt(savedMessage.getSentAt());
            messageDTO.setIsAiGenerated(false);
            
            webSocketService.sendChatMessage(messageDTO);
            
            // G·ª≠i conversation update
            webSocketService.sendConversationUpdate(conversationId, "system_notice", null);
            
            log.info("‚úÖ Sent AI return notice to customer in conversation {}", conversationId);
            
        } catch (Exception e) {
            log.error("Error queuing conversation for AI return: {}", e.getMessage(), e);
            aiResumePending.remove(conversationId);
        }
    }
    
    /**
     * H·ªßy vi·ªác trao l·∫°i cho AI n·∫øu kh√°ch nh·∫Øn tin trong 30 gi√¢y
     * ƒê∆∞·ª£c g·ªçi t·ª´ ChatService khi nh·∫≠n tin nh·∫Øn t·ª´ CUSTOMER
     * 
     * @return true n·∫øu ƒë√£ h·ªßy th√†nh c√¥ng (conversation ƒëang trong queue)
     */
    @Transactional
    public boolean cancelIfPendingByCustomerMessage(Long conversationId) {
        LocalDateTime deadline = aiResumePending.get(conversationId);
        
        if (deadline == null) {
            // Kh√¥ng c√≥ trong queue
            return false;
        }
        
        // Ki·ªÉm tra n·∫øu ch∆∞a h·∫øt h·∫°n
        if (LocalDateTime.now().isBefore(deadline)) {
            // H·ªßy vi·ªác trao l·∫°i cho AI
            aiResumePending.remove(conversationId);
            
            log.info("üö´ Cancelled AI return for conversation {} (customer sent message)", conversationId);
            
            try {
                // G·ª≠i system message th√¥ng b√°o
                Conversation conversation = conversationRepository.findById(conversationId).orElse(null);
                if (conversation != null) {
                    User systemUser = getOrCreateSystemUser();
                    Message systemMessage = new Message();
                    systemMessage.setConversationId(conversationId);
                    systemMessage.setSender(systemUser);
                    systemMessage.setReceiver(conversation.getCustomer());
                    systemMessage.setContent("B·∫°n ƒë√£ nh·∫Øn tin trong th·ªùi gian ch·ªù. Nh√¢n vi√™n s·∫Ω ti·∫øp t·ª•c h·ªó tr·ª£ b·∫°n nh√©! üòä");
                    systemMessage.setIsAiGenerated(false);
                    systemMessage.setSentAt(LocalDateTime.now());
                    Message savedMessage = messageRepository.save(systemMessage);
                    
                    // G·ª≠i message qua WebSocket cho customer
                    com.example.demo.dto.ChatMessageDTO messageDTO = new com.example.demo.dto.ChatMessageDTO();
                    messageDTO.setId(savedMessage.getId());
                    messageDTO.setConversationId(conversationId);
                    messageDTO.setSenderId(systemUser.getId());
                    messageDTO.setSenderName("H·ªá th·ªëng");
                    messageDTO.setContent(savedMessage.getContent());
                    messageDTO.setSentAt(savedMessage.getSentAt());
                    messageDTO.setIsAiGenerated(false);
                    
                    webSocketService.sendChatMessage(messageDTO);
                    webSocketService.sendConversationUpdate(conversationId, "system_notice", null);
                }
            } catch (Exception e) {
                log.error("Error sending cancel notice", e);
            }
            
            return true;
        }
        
        return false;
    }
    
    /**
     * Task ƒë·ªãnh k·ª≥ x·ª≠ l√Ω c√°c conversation ƒë√£ h·∫øt h·∫°n ch·ªù
     * Trao l·∫°i cho AI n·∫øu kh√°ch kh√¥ng nh·∫Øn tin trong 30 gi√¢y
     * Ch·∫°y m·ªói 2 gi√¢y
     */
    @Scheduled(fixedDelay = 2000)
    @Transactional
    public void processPendingReturns() {
        if (aiResumePending.isEmpty()) {
            return;
        }
        
        LocalDateTime now = LocalDateTime.now();
        
        aiResumePending.entrySet().removeIf(entry -> {
            Long conversationId = entry.getKey();
            LocalDateTime deadline = entry.getValue();
            
            // Ki·ªÉm tra n·∫øu ƒë√£ h·∫øt h·∫°n
            if (now.isAfter(deadline)) {
                try {
                    returnConversationToAi(conversationId);
                    log.info("‚úÖ Processed AI return for conversation {}", conversationId);
                    return true; // Remove from queue
                } catch (Exception e) {
                    log.error("Error processing AI return for conversation {}: {}", conversationId, e.getMessage(), e);
                    return true; // Remove anyway to prevent stuck
                }
            }
            
            return false; // Keep in queue
        });
    }
    
    /**
     * Th·ª±c s·ª± trao conversation l·∫°i cho AI
     */
    @Transactional
    public void returnConversationToAi(Long conversationId) {
        Conversation conversation = conversationRepository.findById(conversationId).orElse(null);
        
        if (conversation == null) {
            log.warn("Conversation {} not found when returning to AI", conversationId);
            return;
        }
        
        if (conversation.getAssignedStaff() == null) {
            log.warn("Conversation {} already has no assigned staff", conversationId);
            return;
        }
        
        // Unassign staff v√† ƒë·ªïi v·ªÅ OPEN ƒë·ªÉ AI c√≥ th·ªÉ x·ª≠ l√Ω
        conversation.setAssignedStaff(null);
        conversation.setStatus(ConversationStatus.OPEN);
        conversationRepository.save(conversation);
        
        log.info("ü§ñ Returned conversation {} to AI (unassigned staff)", conversationId);
        
        // G·ª≠i system message + l·ªùi ch√†o c·ªßa AI
        User aiUser = getOrCreateAiUser();
        
        // System message
        User systemUser = getOrCreateSystemUser();
        Message systemMessage = new Message();
        systemMessage.setConversationId(conversationId);
        systemMessage.setSender(systemUser);
        systemMessage.setReceiver(conversation.getCustomer());
        systemMessage.setContent("Hoa AI ƒë√£ ti·∫øp t·ª•c h·ªó tr·ª£ b·∫°n.");
        systemMessage.setIsAiGenerated(false);
        systemMessage.setSentAt(LocalDateTime.now());
        Message savedSystemMessage = messageRepository.save(systemMessage);
        
        // G·ª≠i system message qua WebSocket
        com.example.demo.dto.ChatMessageDTO systemMessageDTO = new com.example.demo.dto.ChatMessageDTO();
        systemMessageDTO.setId(savedSystemMessage.getId());
        systemMessageDTO.setConversationId(conversationId);
        systemMessageDTO.setSenderId(systemUser.getId());
        systemMessageDTO.setSenderName("H·ªá th·ªëng");
        systemMessageDTO.setContent(savedSystemMessage.getContent());
        systemMessageDTO.setSentAt(savedSystemMessage.getSentAt());
        systemMessageDTO.setIsAiGenerated(false);
        webSocketService.sendChatMessage(systemMessageDTO);
        
        // AI greeting
        Message aiGreeting = new Message();
        aiGreeting.setConversationId(conversationId);
        aiGreeting.setSender(aiUser);
        aiGreeting.setReceiver(conversation.getCustomer());
        aiGreeting.setContent("Ch√†o b·∫°n! M√¨nh l√† Hoa AI, s·∫µn s√†ng ti·∫øp t·ª•c t∆∞ v·∫•n cho b·∫°n n√®. B·∫°n c·ª© m√¥ t·∫£ mong mu·ªën, m√¨nh t∆∞ v·∫•n li·ªÅn nh√©! üå∏‚ú®");
        aiGreeting.setIsAiGenerated(true);
        aiGreeting.setSentAt(LocalDateTime.now());
        Message savedAiGreeting = messageRepository.save(aiGreeting);
        
        // G·ª≠i AI greeting qua WebSocket
        com.example.demo.dto.ChatMessageDTO aiMessageDTO = new com.example.demo.dto.ChatMessageDTO();
        aiMessageDTO.setId(savedAiGreeting.getId());
        aiMessageDTO.setConversationId(conversationId);
        aiMessageDTO.setSenderId(aiUser.getId());
        aiMessageDTO.setSenderName("Hoa AI üå∏");
        aiMessageDTO.setContent(savedAiGreeting.getContent());
        aiMessageDTO.setSentAt(savedAiGreeting.getSentAt());
        aiMessageDTO.setIsAiGenerated(true);
        webSocketService.sendChatMessage(aiMessageDTO);
        
        // G·ª≠i conversation update
        webSocketService.sendConversationUpdate(conversationId, "status_change", null);
        
        log.info("‚úÖ AI greeting sent to conversation {}", conversationId);
    }
    
    /**
     * Get or create AI user
     */
    private User getOrCreateAiUser() {
        return userRepository.findByEmail("ai@system.local").orElseGet(() -> {
            log.info("Creating AI system user");
            User aiUser = new User();
            aiUser.setEmail("ai@system.local");
            aiUser.setFirstname("Hoa AI");
            aiUser.setLastname("üå∏");
            aiUser.setPassword(passwordEncoder.encode("ai_system_password_" + System.currentTimeMillis()));
            aiUser.setPhone("0000000000");
            aiUser.setRole(UserRole.STAFF);
            return userRepository.save(aiUser);
        });
    }
    
    /**
     * Get or create system user
     */
    private User getOrCreateSystemUser() {
        return userRepository.findByEmail("system@local").orElseGet(() -> {
            log.info("Creating system user");
            User systemUser = new User();
            systemUser.setEmail("system@local");
            systemUser.setFirstname("H·ªá th·ªëng");
            systemUser.setLastname("StarShop");
            systemUser.setPassword(passwordEncoder.encode("system_password_" + System.currentTimeMillis()));
            systemUser.setPhone("0000000001");
            systemUser.setRole(UserRole.STAFF);
            return userRepository.save(systemUser);
        });
    }
}
